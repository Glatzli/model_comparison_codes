<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/calculations_and_plots/Inn_valley_pressure_tendency.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/calculations_and_plots/Inn_valley_pressure_tendency.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;Calculate pressure tendency along the Inn valley using ZAMG station data.&#10;&#10;This script reads pressure data from three ZAMG stations (Kufstein, Jenbach, and Innsbruck University)&#10;and calculates the pressure tendency (dP/dt) for each station.&#10;&#10;Stations are ordered from east to west along the Inn valley:&#10;1. Kufstein (eastmost, lower Inn valley)&#10;2. Jenbach (middle)&#10;3. Innsbruck University (westmost, upper Inn valley)&#10;&quot;&quot;&quot;&#10;&#10;import pandas as pd&#10;import matplotlib.pyplot as plt&#10;import confg&#10;&#10;&#10;&#10;def calculate_pressure_tendency(df, window='1H'):&#10;    &quot;&quot;&quot;&#10;    Calculate pressure tendency (dP/dt) from pressure time series.&#10;&#10;    Parameters&#10;    ----------&#10;    df : pd.DataFrame&#10;        DataFrame with pressure data&#10;    window : str&#10;        Time window for calculating tendency (default: '1H' = 1 hour)&#10;&#10;    Returns&#10;    -------&#10;    pd.Series&#10;        Pressure tendency in hPa/h&#10;    &quot;&quot;&quot;&#10;    # ZAMG data has 'P' for station pressure and 'P0' for reduced pressure&#10;    # We'll use 'P' (station pressure) for the analysis&#10;    pressure_col = 'P' if 'P' in df.columns else None&#10;&#10;    if pressure_col is None:&#10;        # Try P0 as fallback&#10;        pressure_col = 'P0' if 'P0' in df.columns else None&#10;&#10;    if pressure_col is None:&#10;        raise ValueError(&quot;Could not find pressure column (P or P0) in data&quot;)&#10;&#10;    # Calculate pressure tendency using finite differences&#10;    # Rolling window for smoothing if desired&#10;    pressure = df[pressure_col]&#10;&#10;    # Calculate time derivative (hPa per hour)&#10;    dt_hours = df.index.to_series().diff().dt.total_seconds() / 3600  # Convert to hours&#10;    dp = pressure.diff()&#10;    dp_dt = dp / dt_hours&#10;&#10;    # Optional: apply rolling mean for smoothing&#10;    # dp_dt_smooth = dp_dt.rolling(window=window, center=True).mean()&#10;&#10;    return dp_dt, pressure&#10;&#10;&#10;def plot_pressure_tendency(stations_data, save_path=None):&#10;    &quot;&quot;&quot;&#10;    Plot pressure and pressure tendency for all stations.&#10;&#10;    Parameters&#10;    ----------&#10;    stations_data : dict&#10;        Dictionary with station names as keys and (pressure_tendency, pressure) tuples as values&#10;    save_path : str, optional&#10;        Path to save the figure&#10;    &quot;&quot;&quot;&#10;    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(14, 10), sharex=True)&#10;&#10;    colors = {'Kufstein': 'blue', 'Jenbach': 'green', 'Innsbruck Uni': 'red'}&#10;&#10;    # Plot pressure&#10;    for station_name, (dp_dt, pressure) in stations_data.items():&#10;        ax1.plot(pressure.index, pressure.values, label=station_name,&#10;                color=colors.get(station_name, 'black'), linewidth=2)&#10;&#10;    ax1.set_ylabel('Pressure [hPa]', fontsize=12)&#10;    ax1.set_title('Surface Pressure along the Inn Valley', fontsize=14, fontweight='bold')&#10;    ax1.legend(loc='best')&#10;    ax1.grid(True, alpha=0.3)&#10;&#10;    # Plot pressure tendency&#10;    for station_name, (dp_dt, pressure) in stations_data.items():&#10;        ax2.plot(dp_dt.index, dp_dt.values, label=station_name,&#10;                color=colors.get(station_name, 'black'), linewidth=2)&#10;&#10;    ax2.set_ylabel('Pressure Tendency [hPa/h]', fontsize=12)&#10;    ax2.set_xlabel('Time', fontsize=12)&#10;    ax2.set_title('Pressure Tendency (dP/dt) along the Inn Valley', fontsize=14, fontweight='bold')&#10;    ax2.legend(loc='best')&#10;    ax2.grid(True, alpha=0.3)&#10;    ax2.axhline(y=0, color='black', linestyle='--', alpha=0.5)&#10;&#10;    plt.tight_layout()&#10;&#10;    if save_path:&#10;        plt.savefig(save_path, dpi=300, bbox_inches='tight')&#10;        print(f&quot;Figure saved to: {save_path}&quot;)&#10;&#10;    plt.show()&#10;&#10;    return fig&#10;&#10;&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    &quot;&quot;&quot;&#10;    Main function to calculate and plot pressure tendency along Inn valley.&#10;    &quot;&quot;&quot;&#10;    print(&quot;Reading ZAMG station data...&quot;)&#10;&#10;    # Define stations with their file paths and names&#10;    stations = {&#10;        'Kufstein': confg.kufstein_zamg,&#10;        'Jenbach': confg.jenbach_zamg,&#10;        'Innsbruck Uni': confg.innsbruck_uni_zamg&#10;    }&#10;&#10;    # Dictionary to store results&#10;    stations_data = {}&#10;&#10;    # Read and process each station&#10;    for station_name, filepath in stations.items():&#10;        print(f&quot;\nProcessing {station_name}...&quot;)&#10;        try:&#10;            # Read CSV file with comma separator&#10;            df = pd.read_csv(filepath, sep=',', parse_dates=['time'], index_col='time')&#10;            print(f&quot;  Columns available: {df.columns.tolist()}&quot;)&#10;&#10;            # Subset to specific time range&#10;            df_subset = df.loc['2017-10-15 12:00:00':'2017-10-16 12:00:00']&#10;            # Select only rows at 00 and 30 minute marks (no averaging)&#10;            df_30min = df_subset[df_subset.index.to_series().dt.minute.isin([0, 30])]&#10;            print(f&quot;  Data points at 30min intervals: {len(df_30min)}&quot;)&#10;&#10;            # Calculate pressure tendency&#10;            dp_dt, pressure = calculate_pressure_tendency(df_30min)&#10;            stations_data[station_name] = (dp_dt, pressure)&#10;&#10;            # Print some statistics&#10;            print(f&quot;  Time range: {df.index[0]} to {df.index[-1]}&quot;)&#10;            print(f&quot;  Mean pressure: {pressure.mean():.2f} hPa&quot;)&#10;            print(f&quot;  Mean pressure tendency: {dp_dt.mean():.4f} hPa/h&quot;)&#10;            if not dp_dt.dropna().empty:&#10;                print(f&quot;  Max pressure tendency: {dp_dt.dropna().max():.4f} hPa/h&quot;)&#10;                print(f&quot;  Min pressure tendency: {dp_dt.dropna().min():.4f} hPa/h&quot;)&#10;&#10;        except Exception as e:&#10;            print(f&quot;  Error processing {station_name}: {str(e)}&quot;)&#10;            continue&#10;&#10;    # Plot results&#10;    if stations_data:&#10;        print(&quot;\nCreating plots...&quot;)&#10;        save_path = confg.dir_PLOTS + &quot;/Inn_valley_pressure_tendency.png&quot;&#10;        plot_pressure_tendency(stations_data, save_path=save_path)&#10;    else:&#10;        print(&quot;No data to plot!&quot;)&#10;&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Calculate pressure tendency along the Inn valley using ZAMG station data.&#10;&#10;This script reads pressure data from three ZAMG stations (Kufstein, Jenbach, and Innsbruck University)&#10;and calculates the pressure tendency (dP/dt) for each station.&#10;&#10;Stations are ordered from east to west along the Inn valley:&#10;1. Kufstein (eastmost, lower Inn valley)&#10;2. Jenbach (middle)&#10;3. Innsbruck University (westmost, upper Inn valley)&#10;&quot;&quot;&quot;&#10;&#10;import pandas as pd&#10;import matplotlib.pyplot as plt&#10;import confg&#10;&#10;&#10;&#10;def calculate_pressure_tendency(df, window='1H'):&#10;    &quot;&quot;&quot;&#10;    Calculate pressure tendency (dP/dt) from pressure time series.&#10;&#10;    Parameters&#10;    ----------&#10;    df : pd.DataFrame&#10;        DataFrame with pressure data&#10;    window : str&#10;        Time window for calculating tendency (default: '1H' = 1 hour)&#10;&#10;    Returns&#10;    -------&#10;    pd.Series&#10;        Pressure tendency in hPa/h&#10;    &quot;&quot;&quot;&#10;    # ZAMG data has 'P' for station pressure and 'P0' for reduced pressure&#10;    # We'll use 'P' (station pressure) for the analysis&#10;    pressure_col = 'P' if 'P' in df.columns else None&#10;&#10;    if pressure_col is None:&#10;        # Try P0 as fallback&#10;        pressure_col = 'P0' if 'P0' in df.columns else None&#10;&#10;    if pressure_col is None:&#10;        raise ValueError(&quot;Could not find pressure column (P or P0) in data&quot;)&#10;&#10;    # Calculate pressure tendency using finite differences&#10;    # Rolling window for smoothing if desired&#10;    pressure = df[pressure_col]&#10;&#10;    # Calculate time derivative (hPa per hour)&#10;    dt_hours = df.index.to_series().diff().dt.total_seconds() / 3600  # Convert to hours&#10;    dp = pressure.diff()&#10;    dp_dt = dp / dt_hours&#10;&#10;    # Optional: apply rolling mean for smoothing&#10;    # dp_dt_smooth = dp_dt.rolling(window=window, center=True).mean()&#10;&#10;    return dp_dt, pressure&#10;&#10;&#10;def plot_pressure_tendency(stations_data, save_path=None):&#10;    &quot;&quot;&quot;&#10;    Plot pressure and pressure tendency for all stations.&#10;&#10;    Parameters&#10;    ----------&#10;    stations_data : dict&#10;        Dictionary with station names as keys and (pressure_tendency, pressure) tuples as values&#10;    save_path : str, optional&#10;        Path to save the figure&#10;    &quot;&quot;&quot;&#10;    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(14, 10), sharex=True)&#10;&#10;    colors = {'Kufstein': 'blue', 'Jenbach': 'green', 'Innsbruck Uni': 'red'}&#10;&#10;    # Plot pressure&#10;    for station_name, (dp_dt, pressure) in stations_data.items():&#10;        ax1.plot(pressure.index, pressure.values, label=station_name,&#10;                color=colors.get(station_name, 'black'), linewidth=2)&#10;&#10;    ax1.set_ylabel('Pressure [hPa]', fontsize=12)&#10;    ax1.set_title('Surface Pressure along the Inn Valley', fontsize=14, fontweight='bold')&#10;    ax1.legend(loc='best')&#10;    ax1.grid(True, alpha=0.3)&#10;&#10;    # Plot pressure tendency&#10;    for station_name, (dp_dt, pressure) in stations_data.items():&#10;        ax2.plot(dp_dt.index, dp_dt.values, label=station_name,&#10;                color=colors.get(station_name, 'black'), linewidth=2)&#10;&#10;    ax2.set_ylabel('Pressure Tendency [hPa/h]', fontsize=12)&#10;    ax2.set_xlabel('Time', fontsize=12)&#10;    ax2.set_title('Pressure Tendency (dP/dt) along the Inn Valley', fontsize=14, fontweight='bold')&#10;    ax2.legend(loc='best')&#10;    ax2.grid(True, alpha=0.3)&#10;    ax2.axhline(y=0, color='black', linestyle='--', alpha=0.5)&#10;&#10;    plt.tight_layout()&#10;&#10;    if save_path:&#10;        plt.savefig(save_path, dpi=300, bbox_inches='tight')&#10;        print(f&quot;Figure saved to: {save_path}&quot;)&#10;&#10;    plt.show()&#10;&#10;    return fig&#10;&#10;&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    &quot;&quot;&quot;&#10;    Main function to calculate and plot pressure tendency along Inn valley.&#10;    &quot;&quot;&quot;&#10;    print(&quot;Reading ZAMG station data...&quot;)&#10;&#10;    # Define stations with their file paths and names&#10;    stations = {&#10;        'Kufstein': confg.kufstein_zamg,&#10;        'Jenbach': confg.jenbach_zamg,&#10;        'Innsbruck Uni': confg.innsbruck_uni_zamg&#10;    }&#10;&#10;    # Dictionary to store results&#10;    stations_data = {}&#10;&#10;    # Read and process each station&#10;    for station_name, filepath in stations.items():&#10;        print(f&quot;\nProcessing {station_name}...&quot;)&#10;        try:&#10;            # Read CSV file with comma separator&#10;            df = pd.read_csv(filepath, sep=',', parse_dates=['time'], index_col='time')&#10;            print(f&quot;  Columns available: {df.columns.tolist()}&quot;)&#10;&#10;            # Subset to specific time range&#10;            df_subset = df.loc['2017-10-15 12:00:00':'2017-10-16 12:00:00']&#10;            # Select only rows at 00 and 30 minute marks (no averaging)&#10;            df_30min = df_subset[df_subset.index.to_series().dt.minute.isin([0, 30])]&#10;            print(f&quot;  Data points at 30min intervals: {len(df_30min)}&quot;)&#10;&#10;            # Calculate pressure tendency&#10;            dp_dt, pressure = calculate_pressure_tendency(df_30min)&#10;            stations_data[station_name] = (dp_dt, pressure)&#10;&#10;            # Print some statistics&#10;            print(f&quot;  Time range: {df.index[0]} to {df.index[-1]}&quot;)&#10;            print(f&quot;  Mean pressure: {pressure.mean():.2f} hPa&quot;)&#10;            print(f&quot;  Mean pressure tendency: {dp_dt.mean():.4f} hPa/h&quot;)&#10;            if not dp_dt.dropna().empty:&#10;                print(f&quot;  Max pressure tendency: {dp_dt.dropna().max():.4f} hPa/h&quot;)&#10;                print(f&quot;  Min pressure tendency: {dp_dt.dropna().min():.4f} hPa/h&quot;)&#10;&#10;        except Exception as e:&#10;            print(f&quot;  Error processing {station_name}: {str(e)}&quot;)&#10;            continue&#10;&#10;    # Plot results&#10;    if stations_data:&#10;        print(&quot;\nCreating plots...&quot;)&#10;        save_path = confg.dir_PLOTS + &quot;/Inn_valley_pressure_tendency.png&quot;&#10;        plot_pressure_tendency(stations_data, save_path=save_path)&#10;    else:&#10;        print(&quot;No data to plot!&quot;)&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/plot_timeseries.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/plot_timeseries.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;This script is used to plot the time series of the vertical distribution of potential temperature for all models.&#10;problem: vertical coordinate is not the same for all models =&gt; use pressure?&#10;&quot;&quot;&quot;&#10;&#10;# Fix for OpenMP duplicate library error on Windows&#10;import os&#10;os.environ['KMP_DUPLICATE_LIB_OK'] = 'TRUE'&#10;&#10;import sys&#10;sys.path.append(&quot;D:/MSc_Arbeit/model_comparison_codes&quot;)&#10;import importlib&#10;import read_in_arome&#10;import read_icon_model_3D&#10;import read_ukmo&#10;# importlib.reload(read_icon_model_3D)&#10;import read_wrf_helen&#10;importlib.reload(read_in_arome)&#10;import confg&#10;import xarray as xr&#10;import numpy as np&#10;import matplotlib&#10;import matplotlib.pyplot as plt&#10;import pandas as pd&#10;from colorspace import diverging_hcl&#10;&#10;&#10;&#10;def plot_pot_temp_time_contours(pot_temp, model=&quot;AROME&quot;):&#10;    &quot;&quot;&quot;&#10;    plot pot temp time &amp; height series for all models. HATPRO was interpolated to AROME levels &amp; it's pressure is used&#10;    to compute pot temp.&#10;    thin 1 K pot temp contour lines, thick 5 K pot temp contour lines and red/blue shading for the 1/2 hrly&#10;    warming/cooling in pot temp is plotted&#10;&#10;    :param pot_temp:&#10;    :param model:&#10;    :return:&#10;    &quot;&quot;&quot;&#10;    fig, ax = plt.subplots(figsize=(12, 6))&#10;&#10;    vmin, vmax = -2, 2  # uniform colorbar&#10;    levels = np.arange(vmin, vmax + 0.5, 0.5)&#10;    # limit the time range for the plot&#10;    start_time = pd.to_datetime('2017-10-15 13:00:00', format='%Y-%m-%d %H:%M:%S')&#10;    end_time = pd.to_datetime('2017-10-16 12:00:00', format='%Y-%m-%d %H:%M:%S')&#10;    # pot_temp = pot_temp.sel(time=slice(start_time, end_time))&#10;&#10;    # Plot the filled contours&#10;    contourf = (pot_temp.diff(&quot;time&quot;, n=1) * 2).plot.contourf(ax=ax, x=&quot;time&quot;, y=&quot;height&quot;, levels=levels, cmap=pal1.cmap(),&#10;                                                   add_colorbar=False, vmin=vmin, vmax=vmax)&#10;&#10;    # Plot the contour lines&#10;    contour1 = pot_temp.plot.contour(ax=ax, x=&quot;time&quot;, y=&quot;height&quot;,&#10;                                     levels=np.arange(np.round(pot_temp.min()), np.round(pot_temp.max()), 1),&#10;                                     colors='black', linewidths=0.5)   #.isel(time=slice(1, 100))&#10;    contour5 = pot_temp.plot.contour(ax=ax, x=&quot;time&quot;, y=&quot;height&quot;, levels=np.arange(290, np.round(pot_temp.max()), 5),&#10;                                     colors='black', linewidths=1.5)  #.isel(time=slice(1, 100))&#10;    ax.clabel(contour5)&#10;&#10;    ax.set_xlim(start_time, end_time)&#10;    # Add a colorbar&#10;    cbar = plt.colorbar(contourf, ax=ax)&#10;    cbar.set_label('K hr$^{-1}$')&#10;&#10;    ax.set_title(model + &quot; potential temp time series&quot;)&#10;    if model ==  &quot;HATPRO&quot;:&#10;        ax.set_ylabel(f&quot;height [m]&quot;)&#10;    elif model == &quot;ICON&quot; or model == &quot;ICON2TE&quot;:&#10;        ax.set_ylabel(f&quot;geometric height [m]&quot;)&#10;    else:&#10;        ax.set_ylabel(f&quot;geopotential height [m]&quot;)&#10;    ax.set_xlabel(&quot;&quot;)&#10;&#10;    plt.savefig(confg.dir_PLOTS + model + f&quot;_pot_temp_timeseries_{interface_height}_ibk.png&quot;, dpi=500)&#10;&#10;&#10;def plot_temp_time_contours(temp, model=&quot;AROME&quot;):&#10;    &quot;&quot;&quot;&#10;    plot temp over time &amp; height for all models incl HATPRO.&#10;    :param temp:&#10;    :param model:&#10;    :return:&#10;    &quot;&quot;&quot;&#10;&#10;    fig, ax = plt.subplots(figsize=(12, 6))&#10;&#10;    vmin, vmax = -1.5, 1.5  # uniform colorbar&#10;    levels = np.arange(vmin, vmax + 0.3, 0.3)&#10;&#10;    start_time = pd.to_datetime('2017-10-15 14:00:00', format='%Y-%m-%d %H:%M:%S')&#10;    end_time = pd.to_datetime('2017-10-16 12:00:00', format='%Y-%m-%d %H:%M:%S')&#10;    # temp = temp.sel(time=slice(start_time, end_time))&#10;&#10;    # Plot the filled contours&#10;    contourf = temp.diff(&quot;time&quot;).plot.contourf(ax=ax, x=&quot;time&quot;, y=&quot;height&quot;, levels=levels, cmap=pal1.cmap(),&#10;                                                   add_colorbar=False, vmin=-2, vmax=2)&#10;&#10;    # Plot the contour lines&#10;    contour1 = temp.plot.contour(ax=ax, x=&quot;time&quot;, y=&quot;height&quot;,&#10;                                                                    levels=np.arange(np.round(temp.min()),&#10;                                                                                     np.round(temp.max()), 1),&#10;                                                                    colors='black', linewidths=0.5)   #.isel(time=slice(1, 100))&#10;    contour5 = temp.plot.contour(ax=ax, x=&quot;time&quot;, y=&quot;height&quot;,&#10;                                                                    levels=np.arange(-50, np.round(temp.max()), 5),&#10;                                                                    colors='black', linewidths=1.5)  #.isel(time=slice(1, 100))&#10;    ax.clabel(contour5)&#10;&#10;    ax.set_xlim(start_time, end_time)&#10;    # Add a colorbar&#10;    cbar = plt.colorbar(contourf, ax=ax)&#10;    cbar.set_label('K hr$^{-1}$')&#10;    ax.set_title(model + &quot; temp time series&quot;)&#10;    if model ==  &quot;HATPRO&quot;:&#10;        ax.set_ylabel(f&quot;height [m]&quot;)&#10;    else:&#10;        ax.set_ylabel(f&quot;geopotential height [m]&quot;)&#10;    ax.set_xlabel(&quot;&quot;)&#10;    plt.savefig(confg.dir_PLOTS + model + &quot;_temp_timeseries_ibk.png&quot;, dpi=300)&#10;    plt.show()&#10;&#10;&#10;def plot_arome():&#10;    # arome = read_in_arome.read_in_arome_fixed_point(lat=lat_ibk, lon=lon_ibk, )&#10;    # arome = read_in_arome.read_3D_variables_AROME(variables=[&quot;p&quot;, &quot;th&quot;, &quot;z&quot;], method=&quot;sel&quot;, lat=lat_ibk, lon=lon_ibk)&#10;    # pot_temp = arome.th.isel(nz=np.arange(40, 90))&#10;&#10;    arome = xr.open_dataset(confg.model_folder + &quot;/AROME/&quot; + &quot;AROME_temp_timeseries_ibk.nc&quot;)&#10;    pot_temp = arome.th.where(arome[&quot;height&quot;] &lt;= interface_height, drop=True)&#10;    plot_pot_temp_time_contours(pot_temp, model=&quot;AROME&quot;)&#10;&#10;    # temp = arome.temperature.where(arome.height &lt;= 4000, drop=True)  # tried with normal temp, but you don't see much...&#10;    # plot_temp_time_contours(temp, model=&quot;AROME&quot;)&#10;&#10;def plot_icon():&#10;    &quot;&quot;&quot;icon15 = read_icon_model_3D.read_icon_fixed_point_multiple_hours(day=15, hours=np.arange(14, 23), lon=lon_ibk, lat=lat_ibk, variant=&quot;ICON&quot;)&#10;    icon16 = read_icon_model_3D.read_icon_fixed_point_multiple_hours(day=16, hours=np.arange(0, 9), lon=lon_ibk, lat=lat_ibk, variant=&quot;ICON&quot;)&#10;    variables = [&quot;th&quot;, &quot;temp&quot;, &quot;z_ifc&quot;]  # &quot;temp&quot;, &quot;pres&quot;, &quot;u&quot;, &quot;v&quot;, &quot;w&quot;,&#10;    icon = xr.concat([icon15[variables], icon16[variables]], dim=&quot;time&quot;)&quot;&quot;&quot;&#10;    icon = xr.open_dataset(confg.icon_folder_3D + &quot;/ICON_temp_timeseries_ibk.nc&quot;)&#10;    pot_temp = icon.th.where(icon[&quot;height&quot;] &lt;= interface_height, drop=True)&#10;    plot_pot_temp_time_contours(pot_temp, model=&quot;ICON&quot;)&#10;&#10;def plot_icon2te():&#10;    &quot;&quot;&quot;icon15_2te = read_icon_model_3D.read_icon_fixed_point_multiple_hours(day=15, hours=range(12, 24), lon=lon_ibk,&#10;                                                                         lat=lat_ibk, variant=&quot;ICON2TE&quot;)&#10;    icon16_2te = read_icon_model_3D.read_icon_fixed_point_multiple_hours(day=16, hours=range(00, 13), lon=lon_ibk,&#10;                                                                         lat=lat_ibk, variant=&quot;ICON2TE&quot;)&#10;    variables = [&quot;th&quot;, &quot;temp&quot;]  # [&quot;temp&quot;, &quot;pressure&quot;, &quot;pres&quot;, &quot;u&quot;, &quot;v&quot;, &quot;w&quot;]&#10;    icon2te = xr.concat([icon15_2te[variables], icon16_2te[variables]], dim=&quot;time&quot;)&#10;    icon2te_pot_temp = icon2te.th.isel(height=np.arange(40, 90))&quot;&quot;&quot;&#10;&#10;    icon_2te = xr.open_dataset(confg.icon2TE_folder_3D + &quot;/ICON_2TE_latlon_temp_timeseries_ibk.nc&quot;)&#10;    icon_2te_pot_temp = icon_2te.th.where(icon_2te[&quot;height&quot;] &lt;= interface_height, drop=True)&#10;    plot_pot_temp_time_contours(pot_temp=icon_2te_pot_temp, model=&quot;ICON2TE_latlon&quot;)&#10;&#10;def plot_ukmo():&#10;    um = xr.open_dataset(confg.ukmo_folder + &quot;/UKMO_temp_timeseries_ibk.nc&quot;)&#10;    um_pot_temp = um.th.where(um[&quot;height&quot;] &lt;= interface_height, drop=True)&#10;&#10;    plot_pot_temp_time_contours(pot_temp=um_pot_temp, model=&quot;UKMO&quot;)&#10;&#10;def plot_wrf():&#10;    # wrf = read_wrf_helen.read_wrf_fixed_point(lat=lat_ibk, lon=lon_ibk)&#10;    # wrf_pot_temp = wrf.th.isel(height=slice(0, 50))&#10;&#10;    wrf = xr.open_dataset(confg.wrf_folder + &quot;/WRF_temp_timeseries_ibk.nc&quot;)&#10;    wrf_pot_temp = wrf.th.where(wrf[&quot;height&quot;] &lt;= interface_height, drop=True)&#10;&#10;    plot_pot_temp_time_contours(pot_temp=wrf_pot_temp, model=&quot;WRF&quot;)&#10;&#10;&#10;def plot_hatpro():&#10;    # hatpro = xr.open_dataset(f&quot;{confg.hatpro_folder}/hatpro_merged.nc&quot;)&#10;    # hatpro_temp = hatpro[&quot;temperature&quot;].sel(height=slice(0, 4400))  # select up to 4.400 m&#10;    # plot_temp_time_contours(temp=hatpro_temp, model=&quot;HATPRO&quot;)&#10;    # hatpro&#10;&#10;    # try with hatpro interpolated data&#10;    hatpro = xr.open_dataset(f&quot;{confg.hatpro_folder}/hatpro_interpolated_arome.nc&quot;)&#10;    hatpro_pot_temp = hatpro[&quot;th&quot;].where(hatpro[&quot;height&quot;] &lt;= interface_height, drop=True)  # hatpro[&quot;th&quot;].sel(height=slice(0, 4400))  # select up to 4.400 m&#10;    plot_pot_temp_time_contours(pot_temp=hatpro_pot_temp, model=&quot;HATPRO&quot;)&#10;&#10;if __name__ == '__main__':&#10;    lat_ibk = 47.259998&#10;    lon_ibk = 11.384167&#10;    interface_height = 2500  # what is max height that should be plotted?&#10;    pal1 = diverging_hcl(palette=&quot;Blue-Red 2&quot;)&#10;&#10;    matplotlib.use('Qt5Agg')  # Use the Qt5Agg backend for interactive plotting&#10;&#10;    #plot_arome()&#10;&#10;    plot_icon()&#10;    plot_icon2te()&#10;&#10;    #plot_ukmo()&#10;    #plot_wrf()&#10;    #plot_hatpro()&#10;    plt.show()&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;This script is used to plot the time series of the vertical distribution of potential temperature for all models.&#10;problem: vertical coordinate is not the same for all models =&gt; use pressure?&#10;&quot;&quot;&quot;&#10;&#10;# Fix for OpenMP duplicate library error on Windows&#10;import os&#10;os.environ['KMP_DUPLICATE_LIB_OK'] = 'TRUE'&#10;&#10;import sys&#10;sys.path.append(&quot;D:/MSc_Arbeit/model_comparison_codes&quot;)&#10;import importlib&#10;import read_in_arome&#10;import read_icon_model_3D&#10;import read_ukmo&#10;# importlib.reload(read_icon_model_3D)&#10;import read_wrf_helen&#10;importlib.reload(read_in_arome)&#10;import confg&#10;import xarray as xr&#10;import numpy as np&#10;import matplotlib&#10;import matplotlib.pyplot as plt&#10;import pandas as pd&#10;from colorspace import diverging_hcl&#10;&#10;&#10;&#10;def plot_pot_temp_time_contours(pot_temp, model=&quot;AROME&quot;):&#10;    &quot;&quot;&quot;&#10;    plot pot temp time &amp; height series for all models. HATPRO was interpolated to AROME levels &amp; it's pressure is used&#10;    to compute pot temp.&#10;    thin 1 K pot temp contour lines, thick 5 K pot temp contour lines and red/blue shading for the 1/2 hrly&#10;    warming/cooling in pot temp is plotted&#10;&#10;    :param pot_temp:&#10;    :param model:&#10;    :return:&#10;    &quot;&quot;&quot;&#10;    fig, ax = plt.subplots(figsize=(12, 6))&#10;&#10;    vmin, vmax = -2, 2  # uniform colorbar&#10;    levels = np.arange(vmin, vmax + 0.5, 0.5)&#10;    # limit the time range for the plot&#10;    start_time = pd.to_datetime('2017-10-15 13:00:00', format='%Y-%m-%d %H:%M:%S')&#10;    end_time = pd.to_datetime('2017-10-16 12:00:00', format='%Y-%m-%d %H:%M:%S')&#10;    # pot_temp = pot_temp.sel(time=slice(start_time, end_time))&#10;&#10;    # Plot the filled contours&#10;    contourf = (pot_temp.diff(&quot;time&quot;, n=1) * 2).plot.contourf(ax=ax, x=&quot;time&quot;, y=&quot;height&quot;, levels=levels, cmap=pal1.cmap(),&#10;                                                   add_colorbar=False, vmin=vmin, vmax=vmax)&#10;&#10;    # Plot the contour lines&#10;    contour1 = pot_temp.plot.contour(ax=ax, x=&quot;time&quot;, y=&quot;height&quot;,&#10;                                     levels=np.arange(np.round(pot_temp.min()), np.round(pot_temp.max()), 1),&#10;                                     colors='black', linewidths=0.5)   #.isel(time=slice(1, 100))&#10;    contour5 = pot_temp.plot.contour(ax=ax, x=&quot;time&quot;, y=&quot;height&quot;, levels=np.arange(290, np.round(pot_temp.max()), 5),&#10;                                     colors='black', linewidths=1.5)  #.isel(time=slice(1, 100))&#10;    ax.clabel(contour5)&#10;&#10;    ax.set_xlim(start_time, end_time)&#10;    # Add a colorbar&#10;    cbar = plt.colorbar(contourf, ax=ax)&#10;    cbar.set_label('K hr$^{-1}$')&#10;&#10;    ax.set_title(model + &quot; potential temp time series&quot;)&#10;    if model ==  &quot;HATPRO&quot;:&#10;        ax.set_ylabel(f&quot;height [m]&quot;)&#10;    elif model == &quot;ICON&quot; or model == &quot;ICON2TE&quot;:&#10;        ax.set_ylabel(f&quot;geometric height [m]&quot;)&#10;    else:&#10;        ax.set_ylabel(f&quot;geopotential height [m]&quot;)&#10;    ax.set_xlabel(&quot;&quot;)&#10;&#10;    plt.savefig(confg.dir_PLOTS + model + f&quot;_pot_temp_timeseries_{interface_height}_ibk.png&quot;, dpi=500)&#10;&#10;&#10;def plot_temp_time_contours(temp, model=&quot;AROME&quot;):&#10;    &quot;&quot;&quot;&#10;    plot temp over time &amp; height for all models incl HATPRO.&#10;    :param temp:&#10;    :param model:&#10;    :return:&#10;    &quot;&quot;&quot;&#10;&#10;    fig, ax = plt.subplots(figsize=(12, 6))&#10;&#10;    vmin, vmax = -1.5, 1.5  # uniform colorbar&#10;    levels = np.arange(vmin, vmax + 0.3, 0.3)&#10;&#10;    start_time = pd.to_datetime('2017-10-15 14:00:00', format='%Y-%m-%d %H:%M:%S')&#10;    end_time = pd.to_datetime('2017-10-16 12:00:00', format='%Y-%m-%d %H:%M:%S')&#10;    # temp = temp.sel(time=slice(start_time, end_time))&#10;&#10;    # Plot the filled contours&#10;    contourf = temp.diff(&quot;time&quot;).plot.contourf(ax=ax, x=&quot;time&quot;, y=&quot;height&quot;, levels=levels, cmap=pal1.cmap(),&#10;                                                   add_colorbar=False, vmin=-2, vmax=2)&#10;&#10;    # Plot the contour lines&#10;    contour1 = temp.plot.contour(ax=ax, x=&quot;time&quot;, y=&quot;height&quot;,&#10;                                                                    levels=np.arange(np.round(temp.min()),&#10;                                                                                     np.round(temp.max()), 1),&#10;                                                                    colors='black', linewidths=0.5)   #.isel(time=slice(1, 100))&#10;    contour5 = temp.plot.contour(ax=ax, x=&quot;time&quot;, y=&quot;height&quot;,&#10;                                                                    levels=np.arange(-50, np.round(temp.max()), 5),&#10;                                                                    colors='black', linewidths=1.5)  #.isel(time=slice(1, 100))&#10;    ax.clabel(contour5)&#10;&#10;    ax.set_xlim(start_time, end_time)&#10;    # Add a colorbar&#10;    cbar = plt.colorbar(contourf, ax=ax)&#10;    cbar.set_label('K hr$^{-1}$')&#10;    ax.set_title(model + &quot; temp time series&quot;)&#10;    if model ==  &quot;HATPRO&quot;:&#10;        ax.set_ylabel(f&quot;height [m]&quot;)&#10;    else:&#10;        ax.set_ylabel(f&quot;geopotential height [m]&quot;)&#10;    ax.set_xlabel(&quot;&quot;)&#10;    plt.savefig(confg.dir_PLOTS + model + &quot;_temp_timeseries_ibk.png&quot;, dpi=300)&#10;    plt.show()&#10;&#10;&#10;def plot_arome():&#10;    # arome = read_in_arome.read_in_arome_fixed_point(lat=lat_ibk, lon=lon_ibk, )&#10;    # arome = read_in_arome.read_3D_variables_AROME(variables=[&quot;p&quot;, &quot;th&quot;, &quot;z&quot;], method=&quot;sel&quot;, lat=lat_ibk, lon=lon_ibk)&#10;    # pot_temp = arome.th.isel(nz=np.arange(40, 90))&#10;&#10;    arome = xr.open_dataset(confg.model_folder + &quot;/AROME/&quot; + &quot;AROME_temp_timeseries_ibk.nc&quot;)&#10;    pot_temp = arome.th.where(arome[&quot;height&quot;] &lt;= interface_height, drop=True)&#10;    plot_pot_temp_time_contours(pot_temp, model=&quot;AROME&quot;)&#10;&#10;    # temp = arome.temperature.where(arome.height &lt;= 4000, drop=True)  # tried with normal temp, but you don't see much...&#10;    # plot_temp_time_contours(temp, model=&quot;AROME&quot;)&#10;&#10;def plot_icon():&#10;    &quot;&quot;&quot;icon15 = read_icon_model_3D.read_icon_fixed_point_multiple_hours(day=15, hours=np.arange(14, 23), lon=lon_ibk, lat=lat_ibk, variant=&quot;ICON&quot;)&#10;    icon16 = read_icon_model_3D.read_icon_fixed_point_multiple_hours(day=16, hours=np.arange(0, 9), lon=lon_ibk, lat=lat_ibk, variant=&quot;ICON&quot;)&#10;    variables = [&quot;th&quot;, &quot;temp&quot;, &quot;z_ifc&quot;]  # &quot;temp&quot;, &quot;pres&quot;, &quot;u&quot;, &quot;v&quot;, &quot;w&quot;,&#10;    icon = xr.concat([icon15[variables], icon16[variables]], dim=&quot;time&quot;)&quot;&quot;&quot;&#10;    icon = xr.open_dataset(confg.icon_folder_3D + &quot;/ICON_temp_timeseries_ibk.nc&quot;)&#10;    pot_temp = icon.th.where(icon[&quot;height&quot;] &lt;= interface_height, drop=True)&#10;    plot_pot_temp_time_contours(pot_temp, model=&quot;ICON&quot;)&#10;&#10;def plot_icon2te():&#10;    &quot;&quot;&quot;icon15_2te = read_icon_model_3D.read_icon_fixed_point_multiple_hours(day=15, hours=range(12, 24), lon=lon_ibk,&#10;                                                                         lat=lat_ibk, variant=&quot;ICON2TE&quot;)&#10;    icon16_2te = read_icon_model_3D.read_icon_fixed_point_multiple_hours(day=16, hours=range(00, 13), lon=lon_ibk,&#10;                                                                         lat=lat_ibk, variant=&quot;ICON2TE&quot;)&#10;    variables = [&quot;th&quot;, &quot;temp&quot;]  # [&quot;temp&quot;, &quot;pressure&quot;, &quot;pres&quot;, &quot;u&quot;, &quot;v&quot;, &quot;w&quot;]&#10;    icon2te = xr.concat([icon15_2te[variables], icon16_2te[variables]], dim=&quot;time&quot;)&#10;    icon2te_pot_temp = icon2te.th.isel(height=np.arange(40, 90))&quot;&quot;&quot;&#10;&#10;    icon_2te = xr.open_dataset(confg.icon2TE_folder_3D + &quot;/ICON_2TE_latlon_temp_timeseries_ibk.nc&quot;)&#10;    icon_2te_pot_temp = icon_2te.th.where(icon_2te[&quot;height&quot;] &lt;= interface_height, drop=True)&#10;    plot_pot_temp_time_contours(pot_temp=icon_2te_pot_temp, model=&quot;ICON2TE_latlon&quot;)&#10;&#10;def plot_ukmo():&#10;    um = xr.open_dataset(confg.ukmo_folder + &quot;/UKMO_temp_timeseries_ibk.nc&quot;)&#10;    um_pot_temp = um.th.where(um[&quot;height&quot;] &lt;= interface_height, drop=True)&#10;&#10;    plot_pot_temp_time_contours(pot_temp=um_pot_temp, model=&quot;UKMO&quot;)&#10;&#10;def plot_wrf():&#10;    # wrf = read_wrf_helen.read_wrf_fixed_point(lat=lat_ibk, lon=lon_ibk)&#10;    # wrf_pot_temp = wrf.th.isel(height=slice(0, 50))&#10;&#10;    wrf = xr.open_dataset(confg.wrf_folder + &quot;/WRF_temp_timeseries_ibk.nc&quot;)&#10;    wrf_pot_temp = wrf.th.where(wrf[&quot;height&quot;] &lt;= interface_height, drop=True)&#10;&#10;    plot_pot_temp_time_contours(pot_temp=wrf_pot_temp, model=&quot;WRF&quot;)&#10;&#10;&#10;def plot_hatpro():&#10;    # hatpro = xr.open_dataset(f&quot;{confg.hatpro_folder}/hatpro_merged.nc&quot;)&#10;    # hatpro_temp = hatpro[&quot;temperature&quot;].sel(height=slice(0, 4400))  # select up to 4.400 m&#10;    # plot_temp_time_contours(temp=hatpro_temp, model=&quot;HATPRO&quot;)&#10;    # hatpro&#10;&#10;    # try with hatpro interpolated data&#10;    hatpro = xr.open_dataset(f&quot;{confg.hatpro_folder}/hatpro_interpolated_arome.nc&quot;)&#10;    hatpro_pot_temp = hatpro[&quot;th&quot;].where(hatpro[&quot;height&quot;] &lt;= interface_height, drop=True)  # hatpro[&quot;th&quot;].sel(height=slice(0, 4400))  # select up to 4.400 m&#10;    plot_pot_temp_time_contours(pot_temp=hatpro_pot_temp, model=&quot;HATPRO&quot;)&#10;&#10;if __name__ == '__main__':&#10;    lat_ibk = 47.259998&#10;    lon_ibk = 11.384167&#10;    interface_height = 2500  # what is max height that should be plotted?&#10;    pal1 = diverging_hcl(palette=&quot;Blue-Red 2&quot;)&#10;&#10;    matplotlib.use('Qt5Agg')  # Use the Qt5Agg backend for interactive plotting&#10;&#10;    #plot_arome()&#10;&#10;    plot_icon()&#10;    plot_icon2te()&#10;&#10;    #plot_ukmo()&#10;    #plot_wrf()&#10;    #plot_hatpro()&#10;    plt.show()" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>