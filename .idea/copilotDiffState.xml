<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/calculations_and_plots/plot_vertical_profiles.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/calculations_and_plots/plot_vertical_profiles.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;Plot vertical temperature profiles for all models at fixed points.&#10;&#10;This module creates interactive plots showing temperature profiles with height for different&#10;weather models (AROME, ICON, ICON2TE, UM, WRF) and observations (Radiosonde, HATPRO)&#10;at various locations. The plots include CAP (Cold Air Pool) height markers when available.&#10;&#10;Main functionality:&#10;- Load timeseries data from saved files (or read fresh data if not available)&#10;- Add radiosonde and HATPRO observations for Innsbruck points&#10;- Create small multiples plots showing all points side-by-side&#10;- Save interactive HTML plots&#10;&quot;&quot;&quot;&#10;from __future__ import annotations&#10;&#10;import os&#10;from typing import List&#10;&#10;import numpy as np&#10;import pandas as pd&#10;import plotly.graph_objects as go&#10;import xarray as xr&#10;from colorspace import qualitative_hcl&#10;&#10;import confg&#10;from calculations_and_plots.calc_cap_height import cap_height_profile&#10;# Import timeseries management functions&#10;from calculations_and_plots.manage_timeseries import (load_or_read_timeseries, MODEL_ORDER, ALL_POINTS)&#10;from HATPRO.read_in_hatpro_radiosonde import read_radiosonde_dataset&#10;&#10;# --- Color scheme for models (consistent with plot_cap_height) ---&#10;qualitative_colors_temp = qualitative_hcl(palette=&quot;Dark 2&quot;).colors()&#10;qualitative_colors_humidity = qualitative_hcl(palette=&quot;Dark 3&quot;).colors()&#10;&#10;# Model color mapping for temperature - ICON and ICON2TE share the same color&#10;model_colors_temp = {&quot;AROME&quot;: qualitative_colors_temp[0], &quot;ICON&quot;: qualitative_colors_temp[2],&#10;                     &quot;ICON2TE&quot;: qualitative_colors_temp[2], &quot;UM&quot;: qualitative_colors_temp[4],&#10;                     &quot;WRF&quot;: qualitative_colors_temp[6], &quot;Radiosonde&quot;: &quot;grey&quot;, &quot;HATPRO&quot;: &quot;grey&quot;}&#10;&#10;# Model color mapping for humidity&#10;model_colors_humidity = {&quot;AROME&quot;: qualitative_colors_humidity[0], &quot;ICON&quot;: qualitative_colors_humidity[2],&#10;                         &quot;ICON2TE&quot;: qualitative_colors_humidity[2], &quot;UM&quot;: qualitative_colors_humidity[4],&#10;                         &quot;WRF&quot;: qualitative_colors_humidity[6]}&#10;&#10;&#10;# Observation data paths; is actually in confg!&#10;# RADIOSONDE_PATH = r&quot;D:\MSc_Arbeit\data\radiosonde_ibk_smoothed.nc&quot;&#10;# HATPRO_PATH = r&quot;D:\MSc_Arbeit\data\Observations\HATPRO_obs\hatpro_interpolated_arome_height_as_z.nc&quot;&#10;&#10;&#10;def get_obs_cap_path(obs_type: str) -&gt; str:&#10;    &quot;&quot;&quot;&#10;    Get the path to the computed CAP height file for observations.&#10;    &#10;    Args:&#10;        obs_type: Either &quot;radiosonde&quot; or &quot;hatpro&quot;&#10;    &#10;    Returns:&#10;        Full path to the CAP height NetCDF file&#10;    &quot;&quot;&quot;&#10;    import confg&#10;    cap_dir = os.path.join(confg.data_folder, &quot;calculated_cap_height&quot;)&#10;    return os.path.join(cap_dir, f&quot;{obs_type}_cap_height.nc&quot;)&#10;&#10;&#10;def _get_cap_height_value(cap_height_da: xr.DataArray, point: dict, ts: np.datetime64) -&gt; float:&#10;    &quot;&quot;&quot;&#10;    Extract CAP height value from DataArray, handling different dimension structures.&#10;    Returns NaN if extraction fails.&#10;    &quot;&quot;&quot;&#10;    if not cap_height_da.dims:&#10;        # Scalar value&#10;        return cap_height_da.item()&#10;    &#10;    if &quot;lat&quot; in cap_height_da.dims and &quot;lon&quot; in cap_height_da.dims:&#10;        # Spatial + time dimensions&#10;        return cap_height_da.sel(lat=point[&quot;lat&quot;], lon=point[&quot;lon&quot;], time=ts).item()&#10;    &#10;    # Only time dimension&#10;    return cap_height_da.sel(time=ts, method=&quot;nearest&quot;).item()&#10;&#10;&#10;def _load_or_compute_cap_heights(model: str, ds_filtered: xr.Dataset, point: dict, timestamps: List[str],&#10;                                 ts_array: List[np.datetime64], model_data: dict, max_height: float) -&gt; dict:&#10;    &quot;&quot;&quot;&#10;    Compute CAP heights from timeseries (point) data.&#10;    Returns dict mapping timestamp strings to (temp_at_cap, cap_height) tuples (tuple is needed so that the&#10;    cap-marker is at&#10;    the right temperature in the plot afterwards).&#10;    &quot;&quot;&quot;&#10;    cap_data = {}&#10;    &#10;    ds_with_cap = cap_height_profile(ds_filtered, consecutive=3, model=model)&#10;    cap_height_da = ds_with_cap[&quot;cap_height&quot;]&#10;    &#10;    # Extract CAP heights for each timestamp&#10;    for ts_str, ts in zip(timestamps, ts_array):&#10;        cap_height = _get_cap_height_value(cap_height_da, point, ts)&#10;        &#10;        if np.isnan(cap_height) or cap_height &gt; max_height:&#10;            continue&#10;        &#10;        if ts_str not in model_data[model]:&#10;            continue&#10;        &#10;        temp_data, height_data = model_data[model][ts_str]&#10;        if len(height_data) == 0:&#10;            continue&#10;        &#10;        idx = np.argmin(np.abs(height_data - cap_height))&#10;        temp_at_cap = temp_data[idx]&#10;        cap_data[ts_str] = (temp_at_cap, cap_height)&#10;    &#10;    return cap_data&#10;&#10;&#10;def plot_single_point_with_slider(point_name: str, timestamps: List[str], max_height: float = 5000,&#10;                                  plot_max_height: float = 2000,&#10;                                  variables: list = [&quot;udir&quot;, &quot;wspd&quot;, &quot;q&quot;, &quot;p&quot;, &quot;th&quot;, &quot;temp&quot;, &quot;z&quot;,&#10;                                                     &quot;z_unstag&quot;]) -&gt; go.Figure:&#10;    &quot;&quot;&quot;&#10;    Create an interactive plot with time slider for a single point location.&#10;    &#10;    Users can slide through different timesteps and see the temperature profiles update dynamically.&#10;    The plot shows all models and observations at one location.&#10;    &#10;    Args:&#10;        point_name: Point location name from confg.py (e.g. &quot;ibk_villa&quot;)&#10;        timestamps: List of ISO format timestamp strings&#10;        max_height: Maximum height in meters to load data (default: 5000m)&#10;        plot_max_height: Maximum height in meters to display on y-axis (default: 2000m)&#10;    &#10;    Returns:&#10;        Plotly figure object with the interactive time slider&#10;    &quot;&quot;&quot;&#10;    point = getattr(confg, point_name, None)&#10;    if point is None:&#10;        raise ValueError(f&quot;Point {point_name} not found in confg&quot;)&#10;    &#10;    print(f&quot;Creating slider plot for {point['name']} with {len(timestamps)} timesteps...&quot;)&#10;    &#10;    # Convert timestamp strings to numpy datetime64&#10;    ts_array = [np.datetime64(ts) for ts in timestamps]&#10;    &#10;    # Pre-load all data for all timesteps&#10;    print(f&quot;  Loading data for all models and timesteps...&quot;)&#10;    model_data = {}  # {model: {timestamp: (temp, height)}}&#10;    model_humidity_data = {}  # {model: {timestamp: (q, height)}}&#10;    obs_data = {}  # {obs_type: data}&#10;    cap_data = {}  # {model: {timestamp: (temp_at_cap, cap_height)}}&#10;    &#10;    # Load model data&#10;    for model in MODEL_ORDER:&#10;        model_data[model] = {}&#10;        model_humidity_data[model] = {}&#10;        &#10;        # Load timeseries dataset&#10;        ds = load_or_read_timeseries(model=model, point=point, point_name=point_name, variables_list=variables,&#10;                                     height_as_z_coord=&quot;above_terrain&quot;)&#10;        if ds is None:&#10;            print(f&quot;    Warning: Could not load {model} data&quot;)&#10;            continue&#10;        &#10;        # Get height variable&#10;        if &quot;height&quot; not in ds.coords:&#10;            print(f&quot;    Warning: No height coordinate found for {model}&quot;)&#10;            ds.close()&#10;            continue&#10;        &#10;        height_var = ds.coords[&quot;height&quot;]&#10;        ds_filtered = ds.where(height_var &lt;= max_height, drop=True)&#10;        &#10;        # Extract temperature and height values for each timestamp&#10;        for ts_str, ts in zip(timestamps, ts_array):&#10;            temp = ds_filtered[&quot;temp&quot;].sel(time=ts, method=&quot;nearest&quot;).values&#10;            height = ds_filtered.coords[&quot;height&quot;].values&#10;            &#10;            # Filter NaNs for temperature&#10;            valid = ~np.isnan(temp) &amp; ~np.isnan(height)&#10;            model_data[model][ts_str] = (temp[valid], height[valid])&#10;            &#10;            # Extract humidity data (q) if available&#10;            if &quot;q&quot; in ds_filtered:&#10;                q = ds_filtered[&quot;q&quot;].sel(time=ts, method=&quot;nearest&quot;).values&#10;                # Convert from kg/kg to g/kg&#10;                q = q * 1000&#10;                # Filter NaNs for humidity&#10;                valid_q = ~np.isnan(q) &amp; ~np.isnan(height)&#10;                model_humidity_data[model][ts_str] = (q[valid_q], height[valid_q])&#10;        &#10;        # Load or compute CAP heights&#10;        try:&#10;            cap_data[model] = _load_or_compute_cap_heights(model, ds_filtered, point, timestamps, ts_array, model_data,&#10;                                                           max_height)&#10;        except Exception as e:&#10;            print(f&quot;    Warning: Could not load/compute CAP height for {model}: {e}&quot;)&#10;        &#10;        ds.close()&#10;    &#10;    # Load observation data (only for Innsbruck points)&#10;    if point_name.startswith(&quot;ibk&quot;):&#10;        # Radiosonde (no time dimension)&#10;        try:&#10;            ds_radiosonde = read_radiosonde_dataset(height_as_z_coord=&quot;above_terrain&quot;)&#10;            ds_filtered = ds_radiosonde.where(ds_radiosonde[&quot;height&quot;] &lt;= max_height, drop=True)&#10;            temp = ds_filtered[&quot;temp&quot;].values&#10;            height = ds_filtered[&quot;height&quot;].values&#10;            valid = ~np.isnan(temp) &amp; ~np.isnan(height)&#10;            obs_data[&quot;radiosonde&quot;] = (temp[valid], height[valid])&#10;            &#10;            # set radiosonde CAP height manually&#10;            cap_height = 1537 - confg.ibk_airport[&quot;height&quot;]  # chosen manually from height_as_z_coord=&quot;direct&quot; plot &amp; subtract (real) terrain height&#10;            &#10;            if not np.isnan(cap_height) and cap_height &lt;= max_height:&#10;                idx = np.argmin(np.abs(height[valid] - cap_height))&#10;                obs_data[&quot;radiosonde_cap&quot;] = (temp[valid][idx], cap_height)&#10;            &#10;            ds_radiosonde.close()&#10;        except Exception as e:&#10;            print(f&quot;    Warning: Could not load Radiosonde: {e}&quot;)&#10;        &#10;        # HATPRO (time-dependent)&#10;        try:&#10;            # Check for HATPRO file with CAP height first&#10;            if os.path.exists(confg.hatpro_with_cap_height):&#10;                # Load HATPRO data with pre-computed CAP height&#10;                print(f&quot;    Loading HATPRO data with CAP height&quot;)&#10;                ds_hatpro = xr.open_dataset(confg.hatpro_with_cap_height)&#10;                hatpro_cap_da = ds_hatpro[&quot;cap_height&quot;]&#10;            &#10;            elif os.path.exists(&#10;                    confg.hatpro_calced_vars):  # used interpolated heights to arome levels -&gt; change to&#10;                # smooth HATPRO!&#10;                # Load original HATPRO data and compute CAP height&#10;                print(f&quot;    Loading HATPRO data&quot;)&#10;                ds_hatpro = xr.open_dataset(confg.hatpro_calced_vars)&#10;                &#10;                print(f&quot;    Computing CAP height for HATPRO...&quot;)&#10;                # Filter to max_height before computing CAP&#10;                ds_hatpro_filtered = ds_hatpro.where(ds_hatpro[&quot;height&quot;] &lt;= max_height, drop=True)&#10;                ds_hatpro_with_cap = cap_height_profile(ds_hatpro_filtered, consecutive=3, model=&quot;HATPRO&quot;)&#10;                &#10;                # Add CAP height to original (non-filtered) dataset&#10;                ds_hatpro[&quot;cap_height&quot;] = ds_hatpro_with_cap[&quot;cap_height&quot;]&#10;                hatpro_cap_da = ds_hatpro[&quot;cap_height&quot;]&#10;                &#10;                # Save complete dataset with CAP height&#10;                print(f&quot;    Saving HATPRO dataset with CAP height to {confg.hatpro_with_cap_height}&quot;)&#10;                ds_hatpro.to_netcdf(confg.hatpro_with_cap_height)&#10;                print(f&quot;    ✓ Saved successfully&quot;)&#10;            else:&#10;                print(f&quot;    Warning: HATPRO file not found&quot;)&#10;                ds_hatpro = None&#10;                hatpro_cap_da = None&#10;            &#10;            if ds_hatpro is not None:&#10;                obs_data[&quot;hatpro&quot;] = {}&#10;                obs_data[&quot;hatpro_humidity&quot;] = {}&#10;                &#10;                for ts_str, ts in zip(timestamps, ts_array):&#10;                    ds_ts = ds_hatpro.sel(time=ts)&#10;                    ds_filtered = ds_ts.where(ds_ts[&quot;height&quot;] &lt;= max_height, drop=True)&#10;                    &#10;                    temp = ds_filtered[&quot;temp&quot;].values&#10;                    height = ds_filtered[&quot;height&quot;].values&#10;                    valid = ~np.isnan(temp) &amp; ~np.isnan(height)&#10;                    obs_data[&quot;hatpro&quot;][ts_str] = (temp[valid],&#10;                                                  height[valid])  # creates large dict w. radiosonde w. cap_height &amp;&#10;                    # hatpro data for that timestamp&#10;                    &#10;                    # Extract humidity data (q) if available&#10;                    if &quot;q&quot; in ds_filtered:&#10;                        q = ds_filtered[&quot;q&quot;].values&#10;                        # Convert from kg/kg to g/kg&#10;                        q = q * 1000&#10;                        valid_q = ~np.isnan(q) &amp; ~np.isnan(height)&#10;                        obs_data[&quot;hatpro_humidity&quot;][ts_str] = (q[valid_q], height[valid_q])&#10;                    &#10;                    # CAP height&#10;                    if hatpro_cap_da is not None:&#10;                        cap_height = hatpro_cap_da.sel(time=ts, method=&quot;nearest&quot;).item()&#10;                        if not np.isnan(cap_height) and cap_height &lt;= max_height:&#10;                            idx = np.argmin(np.abs(height[valid] - cap_height))&#10;                            key = f&quot;hatpro_cap_{ts_str}&quot;&#10;                            obs_data[key] = (temp[valid][idx], cap_height)&#10;                &#10;                ds_hatpro.close()&#10;        except Exception as e:&#10;            print(f&quot;    Warning: Could not load HATPRO: {e}&quot;)&#10;    &#10;    print(f&quot;  Creating frames...&quot;)&#10;    &#10;    # probably overkill! -&gt; delete?&#10;    # Calculate maximum humidity value across all models and timesteps for uniform scale&#10;    max_q = 0&#10;    for model in MODEL_ORDER:&#10;        for ts_str in timestamps:&#10;            if ts_str in model_humidity_data.get(model, {}):&#10;                q, _ = model_humidity_data[model][ts_str]&#10;                if len(q) &gt; 0:&#10;                    max_q = max(max_q, np.nanmax(q))&#10;    &#10;    # Round up to nearest 0.5 g/kg for nice scale&#10;    max_q = 30  # np.ceil(max_q * 2) / 2&#10;    # print(f&quot;  Maximum humidity value: {max_q:.1f} g/kg&quot;)&#10;    &#10;    # Create figure with secondary x-axis for humidity&#10;    fig = go.Figure()&#10;    &#10;    # Create frames for slider - one frame per timestep&#10;    frames = []&#10;    for ts_str in timestamps:&#10;        frame_traces = []&#10;        &#10;        # Add model traces (temperature)&#10;        for model in MODEL_ORDER:&#10;            if ts_str in model_data.get(model, {}):&#10;                temp, height = model_data[model][ts_str]&#10;                line_dash = &quot;dash&quot; if model == &quot;ICON2TE&quot; else &quot;solid&quot;&#10;                &#10;                frame_traces.append(go.Scatter(x=temp, y=height, mode='lines', name=model,&#10;                                               line=dict(color=model_colors_temp[model], dash=line_dash, width=1.5),&#10;                                               legendgroup=model, xaxis='x1'))&#10;                &#10;                # Add CAP marker&#10;                if ts_str in cap_data.get(model, {}):&#10;                    temp_cap, height_cap = cap_data[model][ts_str]&#10;                    frame_traces.append(go.Scatter(x=[temp_cap], y=[height_cap], mode='markers',&#10;                                                   marker=dict(symbol='x', size=8, color=model_colors_temp[model],&#10;                                                               line=dict(width=0.5, color=model_colors_temp[model])),&#10;                                                   name=f&quot;{model} CAP&quot;, legendgroup=model, showlegend=False,&#10;                                                   hovertemplate=f&quot;{model} CAP: {height_cap:.0f}m&lt;extra&gt;&lt;/extra&gt;&quot;,&#10;                                                   xaxis='x1'))&#10;        &#10;        # Add humidity traces (on secondary x-axis) with darker colors&#10;        for model in MODEL_ORDER:&#10;            if ts_str in model_humidity_data.get(model, {}):&#10;                q, height = model_humidity_data[model][ts_str]&#10;                line_dash = &quot;dash&quot; if model == &quot;ICON2TE&quot; else &quot;solid&quot;&#10;                &#10;                frame_traces.append(go.Scatter(x=q, y=height, mode='lines', name=f&quot;{model} q&quot;,&#10;                                               line=dict(color=model_colors_humidity[model], dash=line_dash, width=1.0),&#10;                                               legendgroup=model, xaxis='x2', showlegend=False&#10;                                               # Same legendgroup as temp, hide from legend&#10;                                               ))&#10;        &#10;        # Add observation humidity traces (only for Innsbruck points)&#10;        if point_name.startswith(&quot;ibk&quot;):&#10;            # Radiosonde humidity (constant)&#10;            if &quot;radiosonde_humidity&quot; in obs_data:&#10;                q, height = obs_data[&quot;radiosonde_humidity&quot;]&#10;                frame_traces.append(go.Scatter(x=q, y=height, mode='lines', name=&quot;Radiosonde q&quot;,&#10;                                               line=dict(color=&quot;darkgrey&quot;, width=2.0),&#10;                                               legendgroup=&quot;Radiosonde&quot;, xaxis='x2', showlegend=False))&#10;            &#10;            # HATPRO humidity (time-dependent)&#10;            if &quot;hatpro_humidity&quot; in obs_data and ts_str in obs_data[&quot;hatpro_humidity&quot;]:&#10;                q, height = obs_data[&quot;hatpro_humidity&quot;][ts_str]&#10;                frame_traces.append(go.Scatter(x=q, y=height, mode='lines', name=&quot;HATPRO q&quot;,&#10;                                               line=dict(color=&quot;darkgrey&quot;, width=2.0, dash=&quot;dot&quot;),&#10;                                               legendgroup=&quot;HATPRO&quot;, xaxis='x2', showlegend=False))&#10;        &#10;        # Add observations (only for Innsbruck points)&#10;        if point_name.startswith(&quot;ibk&quot;):&#10;            # Radiosonde (constant)&#10;            if &quot;radiosonde&quot; in obs_data:&#10;                temp, height = obs_data[&quot;radiosonde&quot;]&#10;                frame_traces.append(go.Scatter(x=temp, y=height, mode='lines', name=&quot;Radiosonde (from 02:18 UTC)&quot;,&#10;                                               line=dict(color=model_colors_temp[&quot;Radiosonde&quot;], width=2.5),&#10;                                               legendgroup=&quot;Radiosonde&quot;, xaxis='x1'))&#10;                &#10;                if &quot;radiosonde_cap&quot; in obs_data:&#10;                    temp_cap, height_cap = obs_data[&quot;radiosonde_cap&quot;]&#10;                    frame_traces.append(go.Scatter(x=[temp_cap], y=[height_cap], mode='markers',&#10;                                                   marker=dict(symbol='x', size=8,&#10;                                                               color=model_colors_temp[&quot;Radiosonde&quot;],&#10;                                                               line=dict(width=0.5,&#10;                                                                         color=model_colors_temp[&quot;Radiosonde&quot;])),&#10;                                                   name=&quot;Radiosonde CAP&quot;, legendgroup=&quot;Radiosonde&quot;, showlegend=False,&#10;                                                   hovertemplate=f&quot;Radiosonde CAP: {height_cap:.0f}m&lt;extra&gt;&lt;/extra&gt;&quot;,&#10;                                                   xaxis='x1'))&#10;            &#10;            # HATPRO (time-dependent)&#10;            if &quot;hatpro&quot; in obs_data and ts_str in obs_data[&quot;hatpro&quot;]:&#10;                temp, height = obs_data[&quot;hatpro&quot;][ts_str]&#10;                frame_traces.append(go.Scatter(x=temp, y=height, mode='lines', name=&quot;HATPRO&quot;,&#10;                                               line=dict(color=model_colors_temp[&quot;HATPRO&quot;], width=2.5, dash=&quot;dot&quot;),&#10;                                               legendgroup=&quot;HATPRO&quot;, xaxis='x1'))&#10;                &#10;                cap_key = f&quot;hatpro_cap_{ts_str}&quot;&#10;                if cap_key in obs_data:&#10;                    temp_cap, height_cap = obs_data[cap_key]&#10;                    frame_traces.append(go.Scatter(x=[temp_cap], y=[height_cap], mode='markers',&#10;                                                   marker=dict(symbol='x', size=8, color=model_colors_temp[&quot;HATPRO&quot;],&#10;                                                               line=dict(width=0.5, color=model_colors_temp[&quot;HATPRO&quot;])),&#10;                                                   name=&quot;HATPRO CAP&quot;, legendgroup=&quot;HATPRO&quot;, showlegend=False,&#10;                                                   hovertemplate=f&quot;HATPRO CAP: {height_cap:.0f}m&lt;extra&gt;&lt;/extra&gt;&quot;,&#10;                                                   xaxis='x1'))&#10;        &#10;        # Format current timestamp for this frame&#10;        formatted_ts = pd.to_datetime(ts_str).strftime('%dth %H:%M')&#10;        frames.append(go.Frame(data=frame_traces, name=ts_str, layout=go.Layout(&#10;            title_text=f&quot;vertical profile at {point['name']}, {point['height']} m - {formatted_ts}&quot;)))&#10;    &#10;    # Add initial data (first timestep)&#10;    for trace in frames[0].data:&#10;        fig.add_trace(trace)&#10;    &#10;    # Assign frames&#10;    fig.frames = frames&#10;    &#10;    # Create slider&#10;    sliders = [dict(active=0, yanchor=&quot;top&quot;, y=-0.15, xanchor=&quot;left&quot;, x=0.1,&#10;                    currentvalue=dict(prefix=&quot;Time: &quot;, visible=True, xanchor=&quot;center&quot;, font=dict(size=16)),&#10;                    pad=dict(b=10, t=50), len=0.8, transition=dict(duration=0), steps=[dict(&#10;            args=[[ts_str], dict(frame=dict(duration=0, redraw=True), mode=&quot;immediate&quot;, transition=dict(duration=0))],&#10;            label=&quot;&quot;,  # Empty label to hide slider annotations&#10;            method=&quot;animate&quot;) for ts_str in timestamps])]&#10;    &#10;    # Update layout with dual x-axes&#10;    # Format first timestamp as day&quot;th&quot; HH:MM using strftime&#10;    formatted_ts_initial = pd.to_datetime(timestamps[0]).strftime('%dth %H:%M')&#10;    fig.update_layout(title_text=f&quot;vertical profile at {point['name']}, {point['height']} m  - {formatted_ts_initial}&quot;,&#10;                      height=700, width=1200, hovermode='closest', template='plotly_white', sliders=sliders,&#10;                      legend=dict(orientation=&quot;h&quot;, yanchor=&quot;top&quot;, y=-0.15, xanchor=&quot;center&quot;, x=0.5,&#10;                                  bgcolor=&quot;rgba(255, 255, 255, 0.8)&quot;, bordercolor=&quot;lightgray&quot;, borderwidth=1),&#10;                      xaxis=dict(title=&quot;Temperature [°C]&quot;, range=[8, 20], domain=[0, 0.88]&#10;                                 # Leave space for second x-axis&#10;                                 ),&#10;                      xaxis2=dict(title=&quot;Specific Humidity [g/kg]&quot;, overlaying='x', side='top', range=[0, max_q],&#10;                                  # Use calculated max value for uniform scale&#10;                                  domain=[0, 0.88]),&#10;                      yaxis=dict(title=&quot;Height above terrain [m]&quot;, range=[0, plot_max_height]), updatemenus=[&#10;            dict(type=&quot;buttons&quot;, direction=&quot;left&quot;, x=0.0, y=-0.15, xanchor=&quot;left&quot;, yanchor=&quot;top&quot;, pad=dict(t=10, b=10),&#10;                 buttons=[dict(label=&quot;▶ Play&quot;, method=&quot;animate&quot;, args=[None, dict(frame=dict(duration=800, redraw=True),&#10;                                                                                  fromcurrent=True, mode=&quot;immediate&quot;,&#10;                                                                                  transition=dict(duration=0))]),&#10;                          dict(label=&quot;⏸ Pause&quot;, method=&quot;animate&quot;, args=[[None],&#10;                                                                        dict(frame=dict(duration=0, redraw=False),&#10;                                                                             mode=&quot;immediate&quot;,&#10;                                                                             transition=dict(duration=0))])])])&#10;    &#10;    return fig&#10;&#10;&#10;def plot_save_all_points_with_slider(start_time: str = &quot;2017-10-16T00:00:00&quot;, end_time: str = &quot;2017-10-16T12:00:00&quot;,&#10;                                     time_step_hours: float = 1.0, max_height: float = 5000,&#10;                                     plot_max_height: float = 2000, point_names: List[str] = ALL_POINTS) -&gt; None:&#10;    &quot;&quot;&quot;&#10;    Create and save individual slider plots for each point location.&#10;    &#10;    Creates one HTML file per point, each with its own time slider.&#10;    This is more reliable than trying to animate small multiples.&#10;    &#10;    Args:&#10;        start_time: Start timestamp ISO format (e.g. &quot;2017-10-16T00:00:00&quot;)&#10;        end_time: End timestamp ISO format (e.g. &quot;2017-10-16T12:00:00&quot;)&#10;        time_step_hours: Time step in hours between frames (default: 1.0)&#10;        max_height: Maximum height in meters to load data (default: 5000m)&#10;        plot_max_height: Maximum height in meters to display initially (default: 2000m)&#10;        point_names: List of points to plot (default: ALL_POINTS)&#10;    &quot;&quot;&quot;&#10;    &#10;    print(f&quot;\n{'=' * 70}&quot;)&#10;    print(f&quot;Creating individual slider plots for {len(point_names)} points&quot;)&#10;    print(f&quot;Time range: {start_time} to {end_time}, step: {time_step_hours}h&quot;)&#10;    print(f&quot;{'=' * 70}\n&quot;)&#10;    &#10;    # Generate list of timestamps&#10;    timestamps = pd.date_range(start=start_time, end=end_time, freq=f&quot;{int(time_step_hours * 60)}min&quot;).strftime(&#10;        &quot;%Y-%m-%dT%H:%M:%S&quot;).tolist()&#10;    &#10;    print(f&quot;Total timesteps: {len(timestamps)}\n&quot;)&#10;    &#10;    # Ensure output directory exists&#10;    html_dir = os.path.join(confg.dir_PLOTS, &quot;vertical_plots&quot;)&#10;    os.makedirs(html_dir, exist_ok=True)&#10;    &#10;    # Create plot for each point&#10;    for point_name in point_names:&#10;        try:&#10;            point = getattr(confg, point_name, None)&#10;            if point is None:&#10;                print(f&quot;⚠ Skipping {point_name} - not found in confg&quot;)&#10;                continue&#10;            &#10;            print(f&quot;\n{'-' * 70}&quot;)&#10;            print(f&quot;Processing: {point['name']} ({point_name})&quot;)&#10;            print(f&quot;{'-' * 70}&quot;)&#10;            &#10;            # Create the plot with slider&#10;            fig = plot_single_point_with_slider(point_name, timestamps=timestamps, max_height=max_height,&#10;                                                plot_max_height=plot_max_height)&#10;            &#10;            # Save to HTML&#10;            html_path = os.path.join(html_dir, f&quot;vertical_profile_{point_name}_slider.html&quot;)&#10;            fig.write_html(html_path)&#10;            &#10;            print(f&quot;✓ Saved: {html_path}&quot;)&#10;        &#10;        except Exception as e:&#10;            print(f&quot;✗ Error processing {point_name}: {e}&quot;)&#10;            continue&#10;    &#10;    print(f&quot;\n{'=' * 70}&quot;)&#10;    print(f&quot;✓ All plots created successfully!&quot;)&#10;    print(f&quot;  Location: {html_dir}&quot;)&#10;    print(f&quot;  - Use the slider to move through timesteps&quot;)&#10;    print(f&quot;  - Click 'Play' to animate&quot;)&#10;    print(f&quot;  - Data loaded up to {max_height}m, displayed up to {plot_max_height}m&quot;)&#10;    print(f&quot;{'=' * 70}\n&quot;)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    # Create vertical temperature profile plot for 04:00 UTC on October 16, 2017&#10;    # Data is loaded up to 5000m but initially displayed up to 2000m&#10;    # Users can zoom out in the interactive HTML to see higher altitudes&#10;    # plot_save_vertical_profiles(timestamp=&quot;2017-10-16T04:00:00&quot;, max_height=5000, plot_max_height=2000)&#10;    &#10;    # Create interactive plot with time slider&#10;    # Shows profiles from midnight to noon on October 16, 2017&#10;    plot_save_all_points_with_slider(start_time=&quot;2017-10-15T15:00:00&quot;, end_time=&quot;2017-10-16T10:00:00&quot;,&#10;                                     time_step_hours=1, max_height=3000, plot_max_height=800,&#10;                                     point_names=[&quot;ibk_uni&quot;, &quot;telfs&quot;])&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Plot vertical temperature profiles for all models at fixed points.&#10;&#10;This module creates interactive plots showing temperature profiles with height for different&#10;weather models (AROME, ICON, ICON2TE, UM, WRF) and observations (Radiosonde, HATPRO)&#10;at various locations. The plots include CAP (Cold Air Pool) height markers when available.&#10;&#10;Main functionality:&#10;- Load timeseries data from saved files (or read fresh data if not available)&#10;- Add radiosonde and HATPRO observations for Innsbruck points&#10;- Create small multiples plots showing all points side-by-side&#10;- Save interactive HTML plots&#10;&quot;&quot;&quot;&#10;from __future__ import annotations&#10;&#10;import os&#10;from typing import List&#10;&#10;import numpy as np&#10;import pandas as pd&#10;import plotly.graph_objects as go&#10;import xarray as xr&#10;from colorspace import qualitative_hcl&#10;&#10;import confg&#10;from calculations_and_plots.calc_cap_height import cap_height_profile&#10;# Import timeseries management functions&#10;from calculations_and_plots.manage_timeseries import (load_or_read_timeseries, MODEL_ORDER, ALL_POINTS)&#10;from HATPRO.read_in_hatpro_radiosonde import read_radiosonde_dataset&#10;&#10;# --- Color scheme for models (consistent with plot_cap_height) ---&#10;qualitative_colors_temp = qualitative_hcl(palette=&quot;Dark 2&quot;).colors()&#10;qualitative_colors_humidity = qualitative_hcl(palette=&quot;Dark 3&quot;).colors()&#10;&#10;# Model color mapping for temperature - ICON and ICON2TE share the same color&#10;model_colors_temp = {&quot;AROME&quot;: qualitative_colors_temp[0], &quot;ICON&quot;: qualitative_colors_temp[2],&#10;                     &quot;ICON2TE&quot;: qualitative_colors_temp[2], &quot;UM&quot;: qualitative_colors_temp[4],&#10;                     &quot;WRF&quot;: qualitative_colors_temp[6], &quot;Radiosonde&quot;: &quot;grey&quot;, &quot;HATPRO&quot;: &quot;grey&quot;}&#10;&#10;# Model color mapping for humidity&#10;model_colors_humidity = {&quot;AROME&quot;: qualitative_colors_humidity[0], &quot;ICON&quot;: qualitative_colors_humidity[2],&#10;                         &quot;ICON2TE&quot;: qualitative_colors_humidity[2], &quot;UM&quot;: qualitative_colors_humidity[4],&#10;                         &quot;WRF&quot;: qualitative_colors_humidity[6]}&#10;&#10;&#10;# Observation data paths; is actually in confg!&#10;# RADIOSONDE_PATH = r&quot;D:\MSc_Arbeit\data\radiosonde_ibk_smoothed.nc&quot;&#10;# HATPRO_PATH = r&quot;D:\MSc_Arbeit\data\Observations\HATPRO_obs\hatpro_interpolated_arome_height_as_z.nc&quot;&#10;&#10;&#10;def get_obs_cap_path(obs_type: str) -&gt; str:&#10;    &quot;&quot;&quot;&#10;    Get the path to the computed CAP height file for observations.&#10;    &#10;    Args:&#10;        obs_type: Either &quot;radiosonde&quot; or &quot;hatpro&quot;&#10;    &#10;    Returns:&#10;        Full path to the CAP height NetCDF file&#10;    &quot;&quot;&quot;&#10;    import confg&#10;    cap_dir = os.path.join(confg.data_folder, &quot;calculated_cap_height&quot;)&#10;    return os.path.join(cap_dir, f&quot;{obs_type}_cap_height.nc&quot;)&#10;&#10;&#10;def _get_cap_height_value(cap_height_da: xr.DataArray, point: dict, ts: np.datetime64) -&gt; float:&#10;    &quot;&quot;&quot;&#10;    Extract CAP height value from DataArray, handling different dimension structures.&#10;    Returns NaN if extraction fails.&#10;    &quot;&quot;&quot;&#10;    if not cap_height_da.dims:&#10;        # Scalar value&#10;        return cap_height_da.item()&#10;    &#10;    if &quot;lat&quot; in cap_height_da.dims and &quot;lon&quot; in cap_height_da.dims:&#10;        # Spatial + time dimensions&#10;        return cap_height_da.sel(lat=point[&quot;lat&quot;], lon=point[&quot;lon&quot;], time=ts).item()&#10;    &#10;    # Only time dimension&#10;    return cap_height_da.sel(time=ts, method=&quot;nearest&quot;).item()&#10;&#10;&#10;def _load_or_compute_cap_heights(model: str, ds_filtered: xr.Dataset, point: dict, timestamps: List[str],&#10;                                 ts_array: List[np.datetime64], model_data: dict, max_height: float) -&gt; dict:&#10;    &quot;&quot;&quot;&#10;    Compute CAP heights from timeseries (point) data.&#10;    Returns dict mapping timestamp strings to (temp_at_cap, cap_height) tuples (tuple is needed so that the&#10;    cap-marker is at&#10;    the right temperature in the plot afterwards).&#10;    &quot;&quot;&quot;&#10;    cap_data = {}&#10;    &#10;    ds_with_cap = cap_height_profile(ds_filtered, consecutive=3, model=model)&#10;    cap_height_da = ds_with_cap[&quot;cap_height&quot;]&#10;    &#10;    # Extract CAP heights for each timestamp&#10;    for ts_str, ts in zip(timestamps, ts_array):&#10;        cap_height = _get_cap_height_value(cap_height_da, point, ts)&#10;        &#10;        if np.isnan(cap_height) or cap_height &gt; max_height:&#10;            continue&#10;        &#10;        if ts_str not in model_data[model]:&#10;            continue&#10;        &#10;        temp_data, height_data = model_data[model][ts_str]&#10;        if len(height_data) == 0:&#10;            continue&#10;        &#10;        idx = np.argmin(np.abs(height_data - cap_height))&#10;        temp_at_cap = temp_data[idx]&#10;        cap_data[ts_str] = (temp_at_cap, cap_height)&#10;    &#10;    return cap_data&#10;&#10;&#10;def plot_single_point_with_slider(point_name: str, timestamps: List[str], max_height: float = 5000,&#10;                                  plot_max_height: float = 2000,&#10;                                  variables: list = [&quot;udir&quot;, &quot;wspd&quot;, &quot;q&quot;, &quot;p&quot;, &quot;th&quot;, &quot;temp&quot;, &quot;z&quot;,&#10;                                                     &quot;z_unstag&quot;]) -&gt; go.Figure:&#10;    &quot;&quot;&quot;&#10;    Create an interactive plot with time slider for a single point location.&#10;    &#10;    Users can slide through different timesteps and see the temperature profiles update dynamically.&#10;    The plot shows all models and observations at one location.&#10;    &#10;    Args:&#10;        point_name: Point location name from confg.py (e.g. &quot;ibk_villa&quot;)&#10;        timestamps: List of ISO format timestamp strings&#10;        max_height: Maximum height in meters to load data (default: 5000m)&#10;        plot_max_height: Maximum height in meters to display on y-axis (default: 2000m)&#10;    &#10;    Returns:&#10;        Plotly figure object with the interactive time slider&#10;    &quot;&quot;&quot;&#10;    point = getattr(confg, point_name, None)&#10;    if point is None:&#10;        raise ValueError(f&quot;Point {point_name} not found in confg&quot;)&#10;    &#10;    print(f&quot;Creating slider plot for {point['name']} with {len(timestamps)} timesteps...&quot;)&#10;    &#10;    # Convert timestamp strings to numpy datetime64&#10;    ts_array = [np.datetime64(ts) for ts in timestamps]&#10;    &#10;    # Pre-load all data for all timesteps&#10;    print(f&quot;  Loading data for all models and timesteps...&quot;)&#10;    model_data = {}  # {model: {timestamp: (temp, height)}}&#10;    model_humidity_data = {}  # {model: {timestamp: (q, height)}}&#10;    obs_data = {}  # {obs_type: data}&#10;    cap_data = {}  # {model: {timestamp: (temp_at_cap, cap_height)}}&#10;    &#10;    # Load model data&#10;    for model in MODEL_ORDER:&#10;        model_data[model] = {}&#10;        model_humidity_data[model] = {}&#10;        &#10;        # Load timeseries dataset&#10;        ds = load_or_read_timeseries(model=model, point=point, point_name=point_name, variables_list=variables,&#10;                                     height_as_z_coord=&quot;above_terrain&quot;)&#10;        if ds is None:&#10;            print(f&quot;    Warning: Could not load {model} data&quot;)&#10;            continue&#10;        &#10;        # Get height variable&#10;        if &quot;height&quot; not in ds.coords:&#10;            print(f&quot;    Warning: No height coordinate found for {model}&quot;)&#10;            ds.close()&#10;            continue&#10;        &#10;        height_var = ds.coords[&quot;height&quot;]&#10;        ds_filtered = ds.where(height_var &lt;= max_height, drop=True)&#10;        &#10;        # Extract temperature and height values for each timestamp&#10;        for ts_str, ts in zip(timestamps, ts_array):&#10;            temp = ds_filtered[&quot;temp&quot;].sel(time=ts, method=&quot;nearest&quot;).values&#10;            height = ds_filtered.coords[&quot;height&quot;].values&#10;            &#10;            # Filter NaNs for temperature&#10;            valid = ~np.isnan(temp) &amp; ~np.isnan(height)&#10;            model_data[model][ts_str] = (temp[valid], height[valid])&#10;            &#10;            # Extract humidity data (q) if available&#10;            if &quot;q&quot; in ds_filtered:&#10;                q = ds_filtered[&quot;q&quot;].sel(time=ts, method=&quot;nearest&quot;).values&#10;                # Convert from kg/kg to g/kg&#10;                q = q * 1000&#10;                # Filter NaNs for humidity&#10;                valid_q = ~np.isnan(q) &amp; ~np.isnan(height)&#10;                model_humidity_data[model][ts_str] = (q[valid_q], height[valid_q])&#10;        &#10;        # Load or compute CAP heights&#10;        try:&#10;            cap_data[model] = _load_or_compute_cap_heights(model, ds_filtered, point, timestamps, ts_array, model_data,&#10;                                                           max_height)&#10;        except Exception as e:&#10;            print(f&quot;    Warning: Could not load/compute CAP height for {model}: {e}&quot;)&#10;        &#10;        ds.close()&#10;    &#10;    # Load observation data (only for Innsbruck points)&#10;    if point_name.startswith(&quot;ibk&quot;):&#10;        # Radiosonde (no time dimension)&#10;        try:&#10;            ds_radiosonde = read_radiosonde_dataset(height_as_z_coord=&quot;above_terrain&quot;)&#10;            ds_filtered = ds_radiosonde.where(ds_radiosonde[&quot;height&quot;] &lt;= max_height, drop=True)&#10;            temp = ds_filtered[&quot;temp&quot;].values&#10;            height = ds_filtered[&quot;height&quot;].values&#10;            valid = ~np.isnan(temp) &amp; ~np.isnan(height)&#10;            obs_data[&quot;radiosonde&quot;] = (temp[valid], height[valid])&#10;            &#10;            # set radiosonde CAP height manually&#10;            cap_height = 1537 - confg.ibk_airport[&quot;height&quot;]  # chosen manually from height_as_z_coord=&quot;direct&quot; plot &amp; subtract (real) terrain height&#10;            &#10;            if not np.isnan(cap_height) and cap_height &lt;= max_height:&#10;                idx = np.argmin(np.abs(height[valid] - cap_height))&#10;                obs_data[&quot;radiosonde_cap&quot;] = (temp[valid][idx], cap_height)&#10;            &#10;            ds_radiosonde.close()&#10;        except Exception as e:&#10;            print(f&quot;    Warning: Could not load Radiosonde: {e}&quot;)&#10;        &#10;        # HATPRO (time-dependent)&#10;        try:&#10;            # Check for HATPRO file with CAP height first&#10;            if os.path.exists(confg.hatpro_with_cap_height):&#10;                # Load HATPRO data with pre-computed CAP height&#10;                print(f&quot;    Loading HATPRO data with CAP height&quot;)&#10;                ds_hatpro = xr.open_dataset(confg.hatpro_with_cap_height)&#10;                hatpro_cap_da = ds_hatpro[&quot;cap_height&quot;]&#10;            &#10;            elif os.path.exists(&#10;                    confg.hatpro_calced_vars):  # used interpolated heights to arome levels -&gt; change to&#10;                # smooth HATPRO!&#10;                # Load original HATPRO data and compute CAP height&#10;                print(f&quot;    Loading HATPRO data&quot;)&#10;                ds_hatpro = xr.open_dataset(confg.hatpro_calced_vars)&#10;                &#10;                print(f&quot;    Computing CAP height for HATPRO...&quot;)&#10;                # Filter to max_height before computing CAP&#10;                ds_hatpro_filtered = ds_hatpro.where(ds_hatpro[&quot;height&quot;] &lt;= max_height, drop=True)&#10;                ds_hatpro_with_cap = cap_height_profile(ds_hatpro_filtered, consecutive=3, model=&quot;HATPRO&quot;)&#10;                &#10;                # Add CAP height to original (non-filtered) dataset&#10;                ds_hatpro[&quot;cap_height&quot;] = ds_hatpro_with_cap[&quot;cap_height&quot;]&#10;                hatpro_cap_da = ds_hatpro[&quot;cap_height&quot;]&#10;                &#10;                # Save complete dataset with CAP height&#10;                print(f&quot;    Saving HATPRO dataset with CAP height to {confg.hatpro_with_cap_height}&quot;)&#10;                ds_hatpro.to_netcdf(confg.hatpro_with_cap_height)&#10;                print(f&quot;    ✓ Saved successfully&quot;)&#10;            else:&#10;                print(f&quot;    Warning: HATPRO file not found&quot;)&#10;                ds_hatpro = None&#10;                hatpro_cap_da = None&#10;            &#10;            if ds_hatpro is not None:&#10;                obs_data[&quot;hatpro&quot;] = {}&#10;                obs_data[&quot;hatpro_humidity&quot;] = {}&#10;                &#10;                for ts_str, ts in zip(timestamps, ts_array):&#10;                    ds_ts = ds_hatpro.sel(time=ts)&#10;                    ds_filtered = ds_ts.where(ds_ts[&quot;height&quot;] &lt;= max_height, drop=True)&#10;                    &#10;                    temp = ds_filtered[&quot;temp&quot;].values&#10;                    height = ds_filtered[&quot;height&quot;].values&#10;                    valid = ~np.isnan(temp) &amp; ~np.isnan(height)&#10;                    obs_data[&quot;hatpro&quot;][ts_str] = (temp[valid],&#10;                                                  height[valid])  # creates large dict w. radiosonde w. cap_height &amp;&#10;                    # hatpro data for that timestamp&#10;                    &#10;                    # Extract humidity data (q) if available&#10;                    if &quot;q&quot; in ds_filtered:&#10;                        q = ds_filtered[&quot;q&quot;].values&#10;                        # Convert from kg/kg to g/kg&#10;                        q = q * 1000&#10;                        valid_q = ~np.isnan(q) &amp; ~np.isnan(height)&#10;                        obs_data[&quot;hatpro_humidity&quot;][ts_str] = (q[valid_q], height[valid_q])&#10;                    &#10;                    # CAP height&#10;                    if hatpro_cap_da is not None:&#10;                        cap_height = hatpro_cap_da.sel(time=ts, method=&quot;nearest&quot;).item()&#10;                        if not np.isnan(cap_height) and cap_height &lt;= max_height:&#10;                            idx = np.argmin(np.abs(height[valid] - cap_height))&#10;                            key = f&quot;hatpro_cap_{ts_str}&quot;&#10;                            obs_data[key] = (temp[valid][idx], cap_height)&#10;                &#10;                ds_hatpro.close()&#10;        except Exception as e:&#10;            print(f&quot;    Warning: Could not load HATPRO: {e}&quot;)&#10;    &#10;    print(f&quot;  Creating frames...&quot;)&#10;    &#10;    # probably overkill! -&gt; delete?&#10;    # Calculate maximum humidity value across all models and timesteps for uniform scale&#10;    max_q = 0&#10;    for model in MODEL_ORDER:&#10;        for ts_str in timestamps:&#10;            if ts_str in model_humidity_data.get(model, {}):&#10;                q, _ = model_humidity_data[model][ts_str]&#10;                if len(q) &gt; 0:&#10;                    max_q = max(max_q, np.nanmax(q))&#10;    &#10;    # Round up to nearest 0.5 g/kg for nice scale&#10;    max_q = 30  # np.ceil(max_q * 2) / 2&#10;    # print(f&quot;  Maximum humidity value: {max_q:.1f} g/kg&quot;)&#10;    &#10;    # Create figure with secondary x-axis for humidity&#10;    fig = go.Figure()&#10;    &#10;    # Create frames for slider - one frame per timestep&#10;    frames = []&#10;    for ts_str in timestamps:&#10;        frame_traces = []&#10;        &#10;        # Add model traces (temperature)&#10;        for model in MODEL_ORDER:&#10;            if ts_str in model_data.get(model, {}):&#10;                temp, height = model_data[model][ts_str]&#10;                line_dash = &quot;dash&quot; if model == &quot;ICON2TE&quot; else &quot;solid&quot;&#10;                &#10;                frame_traces.append(go.Scatter(x=temp, y=height, mode='lines', name=model,&#10;                                               line=dict(color=model_colors_temp[model], dash=line_dash, width=1.5),&#10;                                               legendgroup=model, xaxis='x1'))&#10;                &#10;                # Add CAP marker&#10;                if ts_str in cap_data.get(model, {}):&#10;                    temp_cap, height_cap = cap_data[model][ts_str]&#10;                    frame_traces.append(go.Scatter(x=[temp_cap], y=[height_cap], mode='markers',&#10;                                                   marker=dict(symbol='x', size=8, color=model_colors_temp[model],&#10;                                                               line=dict(width=0.5, color=model_colors_temp[model])),&#10;                                                   name=f&quot;{model} CAP&quot;, legendgroup=model, showlegend=False,&#10;                                                   hovertemplate=f&quot;{model} CAP: {height_cap:.0f}m&lt;extra&gt;&lt;/extra&gt;&quot;,&#10;                                                   xaxis='x1'))&#10;        &#10;        # Add humidity traces (on secondary x-axis) with darker colors&#10;        for model in MODEL_ORDER:&#10;            if ts_str in model_humidity_data.get(model, {}):&#10;                q, height = model_humidity_data[model][ts_str]&#10;                line_dash = &quot;dash&quot; if model == &quot;ICON2TE&quot; else &quot;solid&quot;&#10;                &#10;                frame_traces.append(go.Scatter(x=q, y=height, mode='lines', name=f&quot;{model} q&quot;,&#10;                                               line=dict(color=model_colors_humidity[model], dash=line_dash, width=1.0),&#10;                                               legendgroup=model, xaxis='x2', showlegend=False&#10;                                               # Same legendgroup as temp, hide from legend&#10;                                               ))&#10;        &#10;        # Add observation humidity traces (only for Innsbruck points)&#10;        if point_name.startswith(&quot;ibk&quot;):&#10;            # Radiosonde humidity (constant)&#10;            if &quot;radiosonde_humidity&quot; in obs_data:&#10;                q, height = obs_data[&quot;radiosonde_humidity&quot;]&#10;                frame_traces.append(go.Scatter(x=q, y=height, mode='lines', name=&quot;Radiosonde q&quot;,&#10;                                               line=dict(color=&quot;darkgrey&quot;, width=2.0),&#10;                                               legendgroup=&quot;Radiosonde&quot;, xaxis='x2', showlegend=False))&#10;            &#10;            # HATPRO humidity (time-dependent)&#10;            if &quot;hatpro_humidity&quot; in obs_data and ts_str in obs_data[&quot;hatpro_humidity&quot;]:&#10;                q, height = obs_data[&quot;hatpro_humidity&quot;][ts_str]&#10;                frame_traces.append(go.Scatter(x=q, y=height, mode='lines', name=&quot;HATPRO q&quot;,&#10;                                               line=dict(color=&quot;darkgrey&quot;, width=2.0, dash=&quot;dot&quot;),&#10;                                               legendgroup=&quot;HATPRO&quot;, xaxis='x2', showlegend=False))&#10;        &#10;        # Add observations (only for Innsbruck points)&#10;        if point_name.startswith(&quot;ibk&quot;):&#10;            # Radiosonde (constant)&#10;            if &quot;radiosonde&quot; in obs_data:&#10;                temp, height = obs_data[&quot;radiosonde&quot;]&#10;                frame_traces.append(go.Scatter(x=temp, y=height, mode='lines', name=&quot;Radiosonde (from 02:18 UTC)&quot;,&#10;                                               line=dict(color=model_colors_temp[&quot;Radiosonde&quot;], width=2.5),&#10;                                               legendgroup=&quot;Radiosonde&quot;, xaxis='x1'))&#10;                &#10;                if &quot;radiosonde_cap&quot; in obs_data:&#10;                    temp_cap, height_cap = obs_data[&quot;radiosonde_cap&quot;]&#10;                    frame_traces.append(go.Scatter(x=[temp_cap], y=[height_cap], mode='markers',&#10;                                                   marker=dict(symbol='x', size=8,&#10;                                                               color=model_colors_temp[&quot;Radiosonde&quot;],&#10;                                                               line=dict(width=0.5,&#10;                                                                         color=model_colors_temp[&quot;Radiosonde&quot;])),&#10;                                                   name=&quot;Radiosonde CAP&quot;, legendgroup=&quot;Radiosonde&quot;, showlegend=False,&#10;                                                   hovertemplate=f&quot;Radiosonde CAP: {height_cap:.0f}m&lt;extra&gt;&lt;/extra&gt;&quot;,&#10;                                                   xaxis='x1'))&#10;            &#10;            # HATPRO (time-dependent)&#10;            if &quot;hatpro&quot; in obs_data and ts_str in obs_data[&quot;hatpro&quot;]:&#10;                temp, height = obs_data[&quot;hatpro&quot;][ts_str]&#10;                frame_traces.append(go.Scatter(x=temp, y=height, mode='lines', name=&quot;HATPRO&quot;,&#10;                                               line=dict(color=model_colors_temp[&quot;HATPRO&quot;], width=2.5, dash=&quot;dot&quot;),&#10;                                               legendgroup=&quot;HATPRO&quot;, xaxis='x1'))&#10;                &#10;                cap_key = f&quot;hatpro_cap_{ts_str}&quot;&#10;                if cap_key in obs_data:&#10;                    temp_cap, height_cap = obs_data[cap_key]&#10;                    frame_traces.append(go.Scatter(x=[temp_cap], y=[height_cap], mode='markers',&#10;                                                   marker=dict(symbol='x', size=8, color=model_colors_temp[&quot;HATPRO&quot;],&#10;                                                               line=dict(width=0.5, color=model_colors_temp[&quot;HATPRO&quot;])),&#10;                                                   name=&quot;HATPRO CAP&quot;, legendgroup=&quot;HATPRO&quot;, showlegend=False,&#10;                                                   hovertemplate=f&quot;HATPRO CAP: {height_cap:.0f}m&lt;extra&gt;&lt;/extra&gt;&quot;,&#10;                                                   xaxis='x1'))&#10;        &#10;        # Format current timestamp for this frame&#10;        formatted_ts = pd.to_datetime(ts_str).strftime('%dth %H:%M')&#10;        frames.append(go.Frame(data=frame_traces, name=ts_str, layout=go.Layout(&#10;            title_text=f&quot;vertical profile at {point['name']}, {point['height']} m - {formatted_ts}&quot;)))&#10;    &#10;    # Add initial data (first timestep)&#10;    for trace in frames[0].data:&#10;        fig.add_trace(trace)&#10;    &#10;    # Assign frames&#10;    fig.frames = frames&#10;    &#10;    # Create slider&#10;    sliders = [dict(active=0, yanchor=&quot;top&quot;, y=-0.15, xanchor=&quot;left&quot;, x=0.1,&#10;                    currentvalue=dict(prefix=&quot;Time: &quot;, visible=True, xanchor=&quot;center&quot;, font=dict(size=16)),&#10;                    pad=dict(b=10, t=50), len=0.8, transition=dict(duration=0), steps=[dict(&#10;            args=[[ts_str], dict(frame=dict(duration=0, redraw=True), mode=&quot;immediate&quot;, transition=dict(duration=0))],&#10;            label=&quot;&quot;,  # Empty label to hide slider annotations&#10;            method=&quot;animate&quot;) for ts_str in timestamps])]&#10;    &#10;    # Update layout with dual x-axes&#10;    # Format first timestamp as day&quot;th&quot; HH:MM using strftime&#10;    formatted_ts_initial = pd.to_datetime(timestamps[0]).strftime('%dth %H:%M')&#10;    fig.update_layout(title_text=f&quot;vertical profile at {point['name']}, {point['height']} m  - {formatted_ts_initial}&quot;,&#10;                      height=700, width=1200, hovermode='closest', template='plotly_white', sliders=sliders,&#10;                      legend=dict(orientation=&quot;h&quot;, yanchor=&quot;top&quot;, y=-0.15, xanchor=&quot;center&quot;, x=0.5,&#10;                                  bgcolor=&quot;rgba(255, 255, 255, 0.8)&quot;, bordercolor=&quot;lightgray&quot;, borderwidth=1),&#10;                      xaxis=dict(title=&quot;Temperature [°C]&quot;, range=[8, 20], domain=[0, 0.88]&#10;                                 # Leave space for second x-axis&#10;                                 ),&#10;                      xaxis2=dict(title=&quot;Specific Humidity [g/kg]&quot;, overlaying='x', side='top', range=[0, max_q],&#10;                                  # Use calculated max value for uniform scale&#10;                                  domain=[0, 0.88]),&#10;                      yaxis=dict(title=&quot;Height above terrain [m]&quot;, range=[0, plot_max_height]), updatemenus=[&#10;            dict(type=&quot;buttons&quot;, direction=&quot;left&quot;, x=0.0, y=-0.15, xanchor=&quot;left&quot;, yanchor=&quot;top&quot;, pad=dict(t=10, b=10),&#10;                 buttons=[dict(label=&quot;▶ Play&quot;, method=&quot;animate&quot;, args=[None, dict(frame=dict(duration=800, redraw=True),&#10;                                                                                  fromcurrent=True, mode=&quot;immediate&quot;,&#10;                                                                                  transition=dict(duration=0))]),&#10;                          dict(label=&quot;⏸ Pause&quot;, method=&quot;animate&quot;, args=[[None],&#10;                                                                        dict(frame=dict(duration=0, redraw=False),&#10;                                                                             mode=&quot;immediate&quot;,&#10;                                                                             transition=dict(duration=0))])])])&#10;    &#10;    return fig&#10;&#10;&#10;def plot_save_all_points_with_slider(start_time: str = &quot;2017-10-16T00:00:00&quot;, end_time: str = &quot;2017-10-16T12:00:00&quot;,&#10;                                     time_step_hours: float = 1.0, max_height: float = 5000,&#10;                                     plot_max_height: float = 2000, point_names: List[str] = ALL_POINTS) -&gt; None:&#10;    &quot;&quot;&quot;&#10;    Create and save individual slider plots for each point location.&#10;    &#10;    Creates one HTML file per point, each with its own time slider.&#10;    This is more reliable than trying to animate small multiples.&#10;    &#10;    Args:&#10;        start_time: Start timestamp ISO format (e.g. &quot;2017-10-16T00:00:00&quot;)&#10;        end_time: End timestamp ISO format (e.g. &quot;2017-10-16T12:00:00&quot;)&#10;        time_step_hours: Time step in hours between frames (default: 1.0)&#10;        max_height: Maximum height in meters to load data (default: 5000m)&#10;        plot_max_height: Maximum height in meters to display initially (default: 2000m)&#10;        point_names: List of points to plot (default: ALL_POINTS)&#10;    &quot;&quot;&quot;&#10;    &#10;    print(f&quot;\n{'=' * 70}&quot;)&#10;    print(f&quot;Creating individual slider plots for {len(point_names)} points&quot;)&#10;    print(f&quot;Time range: {start_time} to {end_time}, step: {time_step_hours}h&quot;)&#10;    print(f&quot;{'=' * 70}\n&quot;)&#10;    &#10;    # Generate list of timestamps&#10;    timestamps = pd.date_range(start=start_time, end=end_time, freq=f&quot;{int(time_step_hours * 60)}min&quot;).strftime(&#10;        &quot;%Y-%m-%dT%H:%M:%S&quot;).tolist()&#10;    &#10;    print(f&quot;Total timesteps: {len(timestamps)}\n&quot;)&#10;    &#10;    # Ensure output directory exists&#10;    html_dir = os.path.join(confg.dir_PLOTS, &quot;vertical_plots&quot;)&#10;    os.makedirs(html_dir, exist_ok=True)&#10;    &#10;    # Create plot for each point&#10;    for point_name in point_names:&#10;        try:&#10;            point = getattr(confg, point_name, None)&#10;            if point is None:&#10;                print(f&quot;⚠ Skipping {point_name} - not found in confg&quot;)&#10;                continue&#10;            &#10;            print(f&quot;\n{'-' * 70}&quot;)&#10;            print(f&quot;Processing: {point['name']} ({point_name})&quot;)&#10;            print(f&quot;{'-' * 70}&quot;)&#10;            &#10;            # Create the plot with slider&#10;            fig = plot_single_point_with_slider(point_name, timestamps=timestamps, max_height=max_height,&#10;                                                plot_max_height=plot_max_height)&#10;            &#10;            # Save to HTML&#10;            html_path = os.path.join(html_dir, f&quot;vertical_profile_{point_name}_slider.html&quot;)&#10;            fig.write_html(html_path)&#10;            &#10;            print(f&quot;✓ Saved: {html_path}&quot;)&#10;        &#10;        except Exception as e:&#10;            print(f&quot;✗ Error processing {point_name}: {e}&quot;)&#10;            continue&#10;    &#10;    print(f&quot;\n{'=' * 70}&quot;)&#10;    print(f&quot;✓ All plots created successfully!&quot;)&#10;    print(f&quot;  Location: {html_dir}&quot;)&#10;    print(f&quot;  - Use the slider to move through timesteps&quot;)&#10;    print(f&quot;  - Click 'Play' to animate&quot;)&#10;    print(f&quot;  - Data loaded up to {max_height}m, displayed up to {plot_max_height}m&quot;)&#10;    print(f&quot;{'=' * 70}\n&quot;)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    # Create vertical temperature profile plot for 04:00 UTC on October 16, 2017&#10;    # Data is loaded up to 5000m but initially displayed up to 2000m&#10;    # Users can zoom out in the interactive HTML to see higher altitudes&#10;    # plot_save_vertical_profiles(timestamp=&quot;2017-10-16T04:00:00&quot;, max_height=5000, plot_max_height=2000)&#10;    &#10;    # Create interactive plot with time slider&#10;    # Shows profiles from midnight to noon on October 16, 2017&#10;    plot_save_all_points_with_slider(start_time=&quot;2017-10-15T15:00:00&quot;, end_time=&quot;2017-10-16T10:00:00&quot;,&#10;                                     time_step_hours=1, max_height=3000, plot_max_height=800,&#10;                                     point_names=[&quot;ibk_uni&quot;, &quot;telfs&quot;])" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>